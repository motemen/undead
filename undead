#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Carp.pm"} = <<'CARP';
  package Carp;
  
  { use 5.006; }
  use strict;
  use warnings;
  
  BEGIN {
      no strict "refs";
      if(exists($::{"utf8::"}) && exists(*{$::{"utf8::"}}{HASH}->{"is_utf8"}) &&
  	    defined(*{*{$::{"utf8::"}}{HASH}->{"is_utf8"}}{CODE})) {
  	*is_utf8 = \&{"utf8::is_utf8"};
      } else {
  	*is_utf8 = sub { 0 };
      }
  }
  
  BEGIN {
      no strict "refs";
      if(exists($::{"utf8::"}) && exists(*{$::{"utf8::"}}{HASH}->{"downgrade"}) &&
  	    defined(*{*{$::{"utf8::"}}{HASH}->{"downgrade"}}{CODE})) {
  	*downgrade = \&{"utf8::downgrade"};
      } else {
  	*downgrade = sub {};
      }
  }
  
  our $VERSION = '1.26';
  
  our $MaxEvalLen = 0;
  our $Verbose    = 0;
  our $CarpLevel  = 0;
  our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
  our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
  
  require Exporter;
  our @ISA       = ('Exporter');
  our @EXPORT    = qw(confess croak carp);
  our @EXPORT_OK = qw(cluck verbose longmess shortmess);
  our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
  
  # The members of %Internal are packages that are internal to perl.
  # Carp will not report errors from within these packages if it
  # can.  The members of %CarpInternal are internal to Perl's warning
  # system.  Carp will not report errors from within these packages
  # either, and will not report calls *to* these packages for carp and
  # croak.  They replace $CarpLevel, which is deprecated.    The
  # $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
  # text and function arguments should be formatted when printed.
  
  our %CarpInternal;
  our %Internal;
  
  # disable these by default, so they can live w/o require Carp
  $CarpInternal{Carp}++;
  $CarpInternal{warnings}++;
  $Internal{Exporter}++;
  $Internal{'Exporter::Heavy'}++;
  
  # if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
  # then the following method will be called by the Exporter which knows
  # to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
  # 'verbose'.
  
  sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
  
  sub _cgc {
      no strict 'refs';
      return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
      return;
  }
  
  sub longmess {
      # Icky backwards compatibility wrapper. :-(
      #
      # The story is that the original implementation hard-coded the
      # number of call levels to go back, so calls to longmess were off
      # by one.  Other code began calling longmess and expecting this
      # behaviour, so the replacement has to emulate that behaviour.
      my $cgc = _cgc();
      my $call_pack = $cgc ? $cgc->() : caller();
      if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
          return longmess_heavy(@_);
      }
      else {
          local $CarpLevel = $CarpLevel + 1;
          return longmess_heavy(@_);
      }
  }
  
  our @CARP_NOT;
  
  sub shortmess {
      my $cgc = _cgc();
  
      # Icky backwards compatibility wrapper. :-(
      local @CARP_NOT = $cgc ? $cgc->() : caller();
      shortmess_heavy(@_);
  }
  
  sub croak   { die shortmess @_ }
  sub confess { die longmess @_ }
  sub carp    { warn shortmess @_ }
  sub cluck   { warn longmess @_ }
  
  BEGIN {
      if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
  	    ("$]" >= 5.012005 && "$]" < 5.013)) {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
      } else {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
      }
  }
  
  sub caller_info {
      my $i = shift(@_) + 1;
      my %call_info;
      my $cgc = _cgc();
      {
  	# Some things override caller() but forget to implement the
  	# @DB::args part of it, which we need.  We check for this by
  	# pre-populating @DB::args with a sentinel which no-one else
  	# has the address of, so that we can detect whether @DB::args
  	# has been properly populated.  However, on earlier versions
  	# of perl this check tickles a bug in CORE::caller() which
  	# leaks memory.  So we only check on fixed perls.
          @DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
          package DB;
          @call_info{
              qw(pack file line sub has_args wantarray evaltext is_require) }
              = $cgc ? $cgc->($i) : caller($i);
      }
  
      unless ( defined $call_info{pack} ) {
          return ();
      }
  
      my $sub_name = Carp::get_subname( \%call_info );
      if ( $call_info{has_args} ) {
          my @args;
          if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1
              && ref $DB::args[0] eq ref \$i
              && $DB::args[0] == \$i ) {
              @DB::args = ();    # Don't let anyone see the address of $i
              local $@;
              my $where = eval {
                  my $func    = $cgc or return '';
                  my $gv      =
                      *{
                          ( $::{"B::"} || return '')       # B stash
                            ->{svref_2object} || return '' # entry in stash
                       }{CODE}                             # coderef in entry
                          ->($func)->GV;
                  my $package = $gv->STASH->NAME;
                  my $subname = $gv->NAME;
                  return unless defined $package && defined $subname;
  
                  # returning CORE::GLOBAL::caller isn't useful for tracing the cause:
                  return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
                  " in &${package}::$subname";
              } || '';
              @args
                  = "** Incomplete caller override detected$where; \@DB::args were not set **";
          }
          else {
              @args = map { Carp::format_arg($_) } @DB::args;
          }
          if ( $MaxArgNums and @args > $MaxArgNums )
          {    # More than we want to show?
              $#args = $MaxArgNums;
              push @args, '...';
          }
  
          # Push the args onto the subroutine
          $sub_name .= '(' . join( ', ', @args ) . ')';
      }
      $call_info{sub_name} = $sub_name;
      return wantarray() ? %call_info : \%call_info;
  }
  
  # Transform an argument to a function into a string.
  sub format_arg {
      my $arg = shift;
      if ( ref($arg) ) {
          $arg = defined($overload::VERSION) ? overload::StrVal($arg) : "$arg";
      }
      if ( defined($arg) ) {
          $arg =~ s/'/\\'/g;
          $arg = str_len_trim( $arg, $MaxArgLen );
  
          # Quote it?
          # Downgrade, and use [0-9] rather than \d, to avoid loading
          # Unicode tables, which would be liable to fail if we're
          # processing a syntax error.
          downgrade($arg, 1);
          $arg = "'$arg'" unless $arg =~ /^-?[0-9.]+\z/;
      }
      else {
          $arg = 'undef';
      }
  
      # The following handling of "control chars" is direct from
      # the original code - it is broken on Unicode though.
      # Suggestions?
      is_utf8($arg)
          or $arg =~ s/([[:cntrl:]]|[[:^ascii:]])/sprintf("\\x{%x}",ord($1))/eg;
      return $arg;
  }
  
  # Takes an inheritance cache and a package and returns
  # an anon hash of known inheritances and anon array of
  # inheritances which consequences have not been figured
  # for.
  sub get_status {
      my $cache = shift;
      my $pkg   = shift;
      $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
      return @{ $cache->{$pkg} };
  }
  
  # Takes the info from caller() and figures out the name of
  # the sub/require/eval
  sub get_subname {
      my $info = shift;
      if ( defined( $info->{evaltext} ) ) {
          my $eval = $info->{evaltext};
          if ( $info->{is_require} ) {
              return "require $eval";
          }
          else {
              $eval =~ s/([\\\'])/\\$1/g;
              return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
          }
      }
  
      return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
  }
  
  # Figures out what call (from the point of view of the caller)
  # the long error backtrace should start at.
  sub long_error_loc {
      my $i;
      my $lvl = $CarpLevel;
      {
          ++$i;
          my $cgc = _cgc();
          my $pkg = $cgc ? $cgc->($i) : caller($i);
          unless ( defined($pkg) ) {
  
              # This *shouldn't* happen.
              if (%Internal) {
                  local %Internal;
                  $i = long_error_loc();
                  last;
              }
              else {
  
                  # OK, now I am irritated.
                  return 2;
              }
          }
          redo if $CarpInternal{$pkg};
          redo unless 0 > --$lvl;
          redo if $Internal{$pkg};
      }
      return $i - 1;
  }
  
  sub longmess_heavy {
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = long_error_loc();
      return ret_backtrace( $i, @_ );
  }
  
  # Returns a full stack backtrace starting from where it is
  # told.
  sub ret_backtrace {
      my ( $i, @error ) = @_;
      my $mess;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      $mess = "$err at $i{file} line $i{line}$tid_msg";
      if( defined $. ) {
          local $@ = '';
          local $SIG{__DIE__};
          eval {
              CORE::die;
          };
          if($@ =~ /^Died at .*(, <.*?> line \d+).$/ ) {
              $mess .= $1;
          }
      }
      $mess .= "\.\n";
  
      while ( my %i = caller_info( ++$i ) ) {
          $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
      }
  
      return $mess;
  }
  
  sub ret_summary {
      my ( $i, @error ) = @_;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      return "$err at $i{file} line $i{line}$tid_msg\.\n";
  }
  
  sub short_error_loc {
      # You have to create your (hash)ref out here, rather than defaulting it
      # inside trusts *on a lexical*, as you want it to persist across calls.
      # (You can default it on $_[2], but that gets messy)
      my $cache = {};
      my $i     = 1;
      my $lvl   = $CarpLevel;
      {
          my $cgc = _cgc();
          my $called = $cgc ? $cgc->($i) : caller($i);
          $i++;
          my $caller = $cgc ? $cgc->($i) : caller($i);
  
          return 0 unless defined($caller);    # What happened?
          redo if $Internal{$caller};
          redo if $CarpInternal{$caller};
          redo if $CarpInternal{$called};
          redo if trusts( $called, $caller, $cache );
          redo if trusts( $caller, $called, $cache );
          redo unless 0 > --$lvl;
      }
      return $i - 1;
  }
  
  sub shortmess_heavy {
      return longmess_heavy(@_) if $Verbose;
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = short_error_loc();
      if ($i) {
          ret_summary( $i, @_ );
      }
      else {
          longmess_heavy(@_);
      }
  }
  
  # If a string is too long, trims it with ...
  sub str_len_trim {
      my $str = shift;
      my $max = shift || 0;
      if ( 2 < $max and $max < length($str) ) {
          substr( $str, $max - 3 ) = '...';
      }
      return $str;
  }
  
  # Takes two packages and an optional cache.  Says whether the
  # first inherits from the second.
  #
  # Recursive versions of this have to work to avoid certain
  # possible endless loops, and when following long chains of
  # inheritance are less efficient.
  sub trusts {
      my $child  = shift;
      my $parent = shift;
      my $cache  = shift;
      my ( $known, $partial ) = get_status( $cache, $child );
  
      # Figure out consequences until we have an answer
      while ( @$partial and not exists $known->{$parent} ) {
          my $anc = shift @$partial;
          next if exists $known->{$anc};
          $known->{$anc}++;
          my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
          my @found = keys %$anc_knows;
          @$known{@found} = ();
          push @$partial, @$anc_partial;
      }
      return exists $known->{$parent};
  }
  
  # Takes a package and gives a list of those trusted directly
  sub trusts_directly {
      my $class = shift;
      no strict 'refs';
      no warnings 'once';
      return @{"$class\::CARP_NOT"}
          ? @{"$class\::CARP_NOT"}
          : @{"$class\::ISA"};
  }
  
  if(!defined($warnings::VERSION) ||
  	do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
      # Very old versions of warnings.pm import from Carp.  This can go
      # wrong due to the circular dependency.  If Carp is invoked before
      # warnings, then Carp starts by loading warnings, then warnings
      # tries to import from Carp, and gets nothing because Carp is in
      # the process of loading and hasn't defined its import method yet.
      # So we work around that by manually exporting to warnings here.
      no strict "refs";
      *{"warnings::$_"} = \&$_ foreach @EXPORT;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Carp - alternative warn and die for modules
  
  =head1 SYNOPSIS
  
      use Carp;
  
      # warn user (from perspective of caller)
      carp "string trimmed to 80 chars";
  
      # die of errors (from perspective of caller)
      croak "We're outta here!";
  
      # die of errors with stack backtrace
      confess "not implemented";
  
      # cluck not exported by default
      use Carp qw(cluck);
      cluck "This is how we got here!";
  
  =head1 DESCRIPTION
  
  The Carp routines are useful in your own modules because
  they act like die() or warn(), but with a message which is more
  likely to be useful to a user of your module.  In the case of
  cluck, confess, and longmess that context is a summary of every
  call in the call-stack.  For a shorter message you can use C<carp>
  or C<croak> which report the error as being from where your module
  was called.  There is no guarantee that that is where the error
  was, but it is a good educated guess.
  
  You can also alter the way the output and logic of C<Carp> works, by
  changing some global variables in the C<Carp> namespace. See the
  section on C<GLOBAL VARIABLES> below.
  
  Here is a more complete description of how C<carp> and C<croak> work.
  What they do is search the call-stack for a function call stack where
  they have not been told that there shouldn't be an error.  If every
  call is marked safe, they give up and give a full stack backtrace
  instead.  In other words they presume that the first likely looking
  potential suspect is guilty.  Their rules for telling whether
  a call shouldn't generate errors work as follows:
  
  =over 4
  
  =item 1.
  
  Any call from a package to itself is safe.
  
  =item 2.
  
  Packages claim that there won't be errors on calls to or from
  packages explicitly marked as safe by inclusion in C<@CARP_NOT>, or
  (if that array is empty) C<@ISA>.  The ability to override what
  @ISA says is new in 5.8.
  
  =item 3.
  
  The trust in item 2 is transitive.  If A trusts B, and B
  trusts C, then A trusts C.  So if you do not override C<@ISA>
  with C<@CARP_NOT>, then this trust relationship is identical to,
  "inherits from".
  
  =item 4.
  
  Any call from an internal Perl module is safe.  (Nothing keeps
  user modules from marking themselves as internal to Perl, but
  this practice is discouraged.)
  
  =item 5.
  
  Any call to Perl's warning system (eg Carp itself) is safe.
  (This rule is what keeps it from reporting the error at the
  point where you call C<carp> or C<croak>.)
  
  =item 6.
  
  C<$Carp::CarpLevel> can be set to skip a fixed number of additional
  call levels.  Using this is not recommended because it is very
  difficult to get it to behave correctly.
  
  =back
  
  =head2 Forcing a Stack Trace
  
  As a debugging aid, you can force Carp to treat a croak as a confess
  and a carp as a cluck across I<all> modules. In other words, force a
  detailed stack trace to be given.  This can be very helpful when trying
  to understand why, or from where, a warning or error is being generated.
  
  This feature is enabled by 'importing' the non-existent symbol
  'verbose'. You would typically enable it by saying
  
      perl -MCarp=verbose script.pl
  
  or by including the string C<-MCarp=verbose> in the PERL5OPT
  environment variable.
  
  Alternately, you can set the global variable C<$Carp::Verbose> to true.
  See the C<GLOBAL VARIABLES> section below.
  
  =head1 GLOBAL VARIABLES
  
  =head2 $Carp::MaxEvalLen
  
  This variable determines how many characters of a string-eval are to
  be shown in the output. Use a value of C<0> to show all text.
  
  Defaults to C<0>.
  
  =head2 $Carp::MaxArgLen
  
  This variable determines how many characters of each argument to a
  function to print. Use a value of C<0> to show the full length of the
  argument.
  
  Defaults to C<64>.
  
  =head2 $Carp::MaxArgNums
  
  This variable determines how many arguments to each function to show.
  Use a value of C<0> to show all arguments to a function call.
  
  Defaults to C<8>.
  
  =head2 $Carp::Verbose
  
  This variable makes C<carp> and C<croak> generate stack backtraces
  just like C<cluck> and C<confess>.  This is how C<use Carp 'verbose'>
  is implemented internally.
  
  Defaults to C<0>.
  
  =head2 @CARP_NOT
  
  This variable, I<in your package>, says which packages are I<not> to be
  considered as the location of an error. The C<carp()> and C<cluck()>
  functions will skip over callers when reporting where an error occurred.
  
  NB: This variable must be in the package's symbol table, thus:
  
      # These work
      our @CARP_NOT; # file scope
      use vars qw(@CARP_NOT); # package scope
      @My::Package::CARP_NOT = ... ; # explicit package variable
  
      # These don't work
      sub xyz { ... @CARP_NOT = ... } # w/o declarations above
      my @CARP_NOT; # even at top-level
  
  Example of use:
  
      package My::Carping::Package;
      use Carp;
      our @CARP_NOT;
      sub bar     { .... or _error('Wrong input') }
      sub _error  {
          # temporary control of where'ness, __PACKAGE__ is implicit
          local @CARP_NOT = qw(My::Friendly::Caller);
          carp(@_)
      }
  
  This would make C<Carp> report the error as coming from a caller not
  in C<My::Carping::Package>, nor from C<My::Friendly::Caller>.
  
  Also read the L</DESCRIPTION> section above, about how C<Carp> decides
  where the error is reported from.
  
  Use C<@CARP_NOT>, instead of C<$Carp::CarpLevel>.
  
  Overrides C<Carp>'s use of C<@ISA>.
  
  =head2 %Carp::Internal
  
  This says what packages are internal to Perl.  C<Carp> will never
  report an error as being from a line in a package that is internal to
  Perl.  For example:
  
      $Carp::Internal{ (__PACKAGE__) }++;
      # time passes...
      sub foo { ... or confess("whatever") };
  
  would give a full stack backtrace starting from the first caller
  outside of __PACKAGE__.  (Unless that package was also internal to
  Perl.)
  
  =head2 %Carp::CarpInternal
  
  This says which packages are internal to Perl's warning system.  For
  generating a full stack backtrace this is the same as being internal
  to Perl, the stack backtrace will not start inside packages that are
  listed in C<%Carp::CarpInternal>.  But it is slightly different for
  the summary message generated by C<carp> or C<croak>.  There errors
  will not be reported on any lines that are calling packages in
  C<%Carp::CarpInternal>.
  
  For example C<Carp> itself is listed in C<%Carp::CarpInternal>.
  Therefore the full stack backtrace from C<confess> will not start
  inside of C<Carp>, and the short message from calling C<croak> is
  not placed on the line where C<croak> was called.
  
  =head2 $Carp::CarpLevel
  
  This variable determines how many additional call frames are to be
  skipped that would not otherwise be when reporting where an error
  occurred on a call to one of C<Carp>'s functions.  It is fairly easy
  to count these call frames on calls that generate a full stack
  backtrace.  However it is much harder to do this accounting for calls
  that generate a short message.  Usually people skip too many call
  frames.  If they are lucky they skip enough that C<Carp> goes all of
  the way through the call stack, realizes that something is wrong, and
  then generates a full stack backtrace.  If they are unlucky then the
  error is reported from somewhere misleading very high in the call
  stack.
  
  Therefore it is best to avoid C<$Carp::CarpLevel>.  Instead use
  C<@CARP_NOT>, C<%Carp::Internal> and C<%Carp::CarpInternal>.
  
  Defaults to C<0>.
  
  =head1 BUGS
  
  The Carp routines don't handle exception objects currently.
  If called with a first argument that is a reference, they simply
  call die() or warn(), as appropriate.
  
  =head1 SEE ALSO
  
  L<Carp::Always>,
  L<Carp::Clan>
  
  =head1 AUTHOR
  
  The Carp module first appeared in Larry Wall's perl 5.000 distribution.
  Since then it has been modified by several of the perl 5 porters.
  Andrew Main (Zefram) <zefram@fysh.org> divested Carp into an independent
  distribution.
  
  =head1 COPYRIGHT
  
  Copyright (C) 1994-2012 Larry Wall
  
  Copyright (C) 2011, 2012 Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
CARP

$fatpacked{"Carp/Heavy.pm"} = <<'CARP_HEAVY';
  package Carp::Heavy;
  
  use Carp ();
  
  our $VERSION = '1.26';
  
  1;
  
  # Most of the machinery of Carp used to be here.
  # It has been moved in Carp.pm now, but this placeholder remains for
  # the benefit of modules that like to preload Carp::Heavy directly.
  # This must load Carp, because some modules rely on the historical
  # behaviour of Carp::Heavy loading Carp.
CARP_HEAVY

$fatpacked{"IPC/Run.pm"} = <<'IPC_RUN';
  package IPC::Run;
  use bytes;
  
  =pod
  
  =head1 NAME
  
  IPC::Run - system() and background procs w/ piping, redirs, ptys (Unix, Win32)
  
  =head1 SYNOPSIS
  
     ## First,a command to run:
        my @cat = qw( cat );
  
     ## Using run() instead of system():
        use IPC::Run qw( run timeout );
  
        run \@cmd, \$in, \$out, \$err, timeout( 10 ) or die "cat: $?"
  
        # Can do I/O to sub refs and filenames, too:
        run \@cmd, '<', "in.txt", \&out, \&err or die "cat: $?"
        run \@cat, '<', "in.txt", '>>', "out.txt", '2>>', "err.txt";
  
  
        # Redirecting using psuedo-terminals instad of pipes.
        run \@cat, '<pty<', \$in,  '>pty>', \$out_and_err;
  
     ## Scripting subprocesses (like Expect):
  
        use IPC::Run qw( start pump finish timeout );
  
        # Incrementally read from / write to scalars. 
        # $in is drained as it is fed to cat's stdin,
        # $out accumulates cat's stdout
        # $err accumulates cat's stderr
        # $h is for "harness".
        my $h = start \@cat, \$in, \$out, \$err, timeout( 10 );
  
        $in .= "some input\n";
        pump $h until $out =~ /input\n/g;
  
        $in .= "some more input\n";
        pump $h until $out =~ /\G.*more input\n/;
  
        $in .= "some final input\n";
        finish $h or die "cat returned $?";
  
        warn $err if $err; 
        print $out;         ## All of cat's output
  
     # Piping between children
        run \@cat, '|', \@gzip;
  
     # Multiple children simultaneously (run() blocks until all
     # children exit, use start() for background execution):
        run \@foo1, '&', \@foo2;
  
     # Calling \&set_up_child in the child before it executes the
     # command (only works on systems with true fork() & exec())
     # exceptions thrown in set_up_child() will be propagated back
     # to the parent and thrown from run().
        run \@cat, \$in, \$out,
           init => \&set_up_child;
  
     # Read from / write to file handles you open and close
        open IN,  '<in.txt'  or die $!;
        open OUT, '>out.txt' or die $!;
        print OUT "preamble\n";
        run \@cat, \*IN, \*OUT or die "cat returned $?";
        print OUT "postamble\n";
        close IN;
        close OUT;
  
     # Create pipes for you to read / write (like IPC::Open2 & 3).
        $h = start
           \@cat,
              '<pipe', \*IN,
              '>pipe', \*OUT,
              '2>pipe', \*ERR 
           or die "cat returned $?";
        print IN "some input\n";
        close IN;
        print <OUT>, <ERR>;
        finish $h;
  
     # Mixing input and output modes
        run \@cat, 'in.txt', \&catch_some_out, \*ERR_LOG );
  
     # Other redirection constructs
        run \@cat, '>&', \$out_and_err;
        run \@cat, '2>&1';
        run \@cat, '0<&3';
        run \@cat, '<&-';
        run \@cat, '3<', \$in3;
        run \@cat, '4>', \$out4;
        # etc.
  
     # Passing options:
        run \@cat, 'in.txt', debug => 1;
  
     # Call this system's shell, returns TRUE on 0 exit code
     # THIS IS THE OPPOSITE SENSE OF system()'s RETURN VALUE
        run "cat a b c" or die "cat returned $?";
  
     # Launch a sub process directly, no shell.  Can't do redirection
     # with this form, it's here to behave like system() with an
     # inverted result.
        $r = run "cat a b c";
  
     # Read from a file in to a scalar
        run io( "filename", 'r', \$recv );
        run io( \*HANDLE,   'r', \$recv );
  
  =head1 DESCRIPTION
  
  IPC::Run allows you to run and interact with child processes using files, pipes,
  and pseudo-ttys.  Both system()-style and scripted usages are supported and
  may be mixed.  Likewise, functional and OO API styles are both supported and
  may be mixed.
  
  Various redirection operators reminiscent of those seen on common Unix and DOS
  command lines are provided.
  
  Before digging in to the details a few LIMITATIONS are important enough
  to be mentioned right up front:
  
  =over
  
  =item Win32 Support
  
  Win32 support is working but B<EXPERIMENTAL>, but does pass all relevant tests
  on NT 4.0.  See L</Win32 LIMITATIONS>.
  
  =item pty Support
  
  If you need pty support, IPC::Run should work well enough most of the
  time, but IO::Pty is being improved, and IPC::Run will be improved to
  use IO::Pty's new features when it is release.
  
  The basic problem is that the pty needs to initialize itself before the
  parent writes to the master pty, or the data written gets lost.  So
  IPC::Run does a sleep(1) in the parent after forking to (hopefully) give
  the child a chance to run.  This is a kludge that works well on non
  heavily loaded systems :(.
  
  ptys are not supported yet under Win32, but will be emulated...
  
  =item Debugging Tip
  
  You may use the environment variable C<IPCRUNDEBUG> to see what's going on
  under the hood:
  
     $ IPCRUNDEBUG=basic   myscript     # prints minimal debugging
     $ IPCRUNDEBUG=data    myscript     # prints all data reads/writes
     $ IPCRUNDEBUG=details myscript     # prints lots of low-level details
     $ IPCRUNDEBUG=gory    myscript     # (Win32 only) prints data moving through
                                        # the helper processes.
  
  =back
  
  We now return you to your regularly scheduled documentation.
  
  =head2 Harnesses
  
  Child processes and I/O handles are gathered in to a harness, then
  started and run until the processing is finished or aborted.
  
  =head2 run() vs. start(); pump(); finish();
  
  There are two modes you can run harnesses in: run() functions as an
  enhanced system(), and start()/pump()/finish() allow for background
  processes and scripted interactions with them.
  
  When using run(), all data to be sent to the harness is set up in
  advance (though one can feed subprocesses input from subroutine refs to
  get around this limitation). The harness is run and all output is
  collected from it, then any child processes are waited for:
  
     run \@cmd, \<<IN, \$out;
     blah
     IN
  
     ## To precompile harnesses and run them later:
     my $h = harness \@cmd, \<<IN, \$out;
     blah
     IN
  
     run $h;
  
  The background and scripting API is provided by start(), pump(), and
  finish(): start() creates a harness if need be (by calling harness())
  and launches any subprocesses, pump() allows you to poll them for
  activity, and finish() then monitors the harnessed activities until they
  complete.
  
     ## Build the harness, open all pipes, and launch the subprocesses
     my $h = start \@cat, \$in, \$out;
     $in = "first input\n";
  
     ## Now do I/O.  start() does no I/O.
     pump $h while length $in;  ## Wait for all input to go
  
     ## Now do some more I/O.
     $in = "second input\n";
     pump $h until $out =~ /second input/;
  
     ## Clean up
     finish $h or die "cat returned $?";
  
  You can optionally compile the harness with harness() prior to
  start()ing or run()ing, and you may omit start() between harness() and
  pump().  You might want to do these things if you compile your harnesses
  ahead of time.
  
  =head2 Using regexps to match output
  
  As shown in most of the scripting examples, the read-to-scalar facility
  for gathering subcommand's output is often used with regular expressions
  to detect stopping points.  This is because subcommand output often
  arrives in dribbles and drabs, often only a character or line at a time.
  This output is input for the main program and piles up in variables like
  the C<$out> and C<$err> in our examples.
  
  Regular expressions can be used to wait for appropriate output in
  several ways.  The C<cat> example in the previous section demonstrates
  how to pump() until some string appears in the output.  Here's an
  example that uses C<smb> to fetch files from a remote server:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /src:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
  Notice that we carefully clear $out after the first command/response
  cycle? That's because IPC::Run does not delete $out when we continue,
  and we don't want to trip over the old output in the second
  command/response cycle.
  
  Say you want to accumulate all the output in $out and analyze it
  afterwards.  Perl offers incremental regular expression matching using
  the C<m//gc> and pattern matching idiom and the C<\G> assertion.
  IPC::Run is careful not to disturb the current C<pos()> value for
  scalars it appends data to, so we could modify the above so as not to
  destroy $out by adding a couple of C</gc> modifiers.  The C</g> keeps us
  from tripping over the previous prompt and the C</c> keeps us from
  resetting the prior match position if the expected prompt doesn't
  materialize immediately:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error cding to /src:\n$out" if $out =~ "ERR";
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
     analyze( $out );
  
  When using this technique, you may want to preallocate $out to have
  plenty of memory or you may find that the act of growing $out each time
  new input arrives causes an C<O(length($out)^2)> slowdown as $out grows.
  Say we expect no more than 10,000 characters of input at the most.  To
  preallocate memory to $out, do something like:
  
     my $out = "x" x 10_000;
     $out = "";
  
  C<perl> will allocate at least 10,000 characters' worth of space, then
  mark the $out as having 0 length without freeing all that yummy RAM.
  
  =head2 Timeouts and Timers
  
  More than likely, you don't want your subprocesses to run forever, and
  sometimes it's nice to know that they're going a little slowly.
  Timeouts throw exceptions after a some time has elapsed, timers merely
  cause pump() to return after some time has elapsed.  Neither is
  reset/restarted automatically.
  
  Timeout objects are created by calling timeout( $interval ) and passing
  the result to run(), start() or harness().  The timeout period starts
  ticking just after all the child processes have been fork()ed or
  spawn()ed, and are polled for expiration in run(), pump() and finish().
  If/when they expire, an exception is thrown.  This is typically useful
  to keep a subprocess from taking too long.
  
  If a timeout occurs in run(), all child processes will be terminated and
  all file/pipe/ptty descriptors opened by run() will be closed.  File
  descriptors opened by the parent process and passed in to run() are not
  closed in this event.
  
  If a timeout occurs in pump(), pump_nb(), or finish(), it's up to you to
  decide whether to kill_kill() all the children or to implement some more
  graceful fallback.  No I/O will be closed in pump(), pump_nb() or
  finish() by such an exception (though I/O is often closed down in those
  routines during the natural course of events).
  
  Often an exception is too harsh.  timer( $interval ) creates timer
  objects that merely prevent pump() from blocking forever.  This can be
  useful for detecting stalled I/O or printing a soothing message or "."
  to pacify an anxious user.
  
  Timeouts and timers can both be restarted at any time using the timer's
  start() method (this is not the start() that launches subprocesses).  To
  restart a timer, you need to keep a reference to the timer:
  
     ## Start with a nice long timeout to let smbclient connect.  If
     ## pump or finish take too long, an exception will be thrown.
  
   my $h;
   eval {
     $h = harness \@smbclient, \$in, \$out, \$err, ( my $t = timeout 30 );
     sleep 11;  # No effect: timer not running yet
  
     start $h;
     $in = "cd /src\n";
     pump $h until ! length $in;
  
     $in = "ls\n";
     ## Now use a short timeout, since this should be faster
     $t->start( 5 );
     pump $h until ! length $in;
  
     $t->start( 10 );  ## Give smbclient a little while to shut down.
     $h->finish;
   };
   if ( $@ ) {
     my $x = $@;    ## Preserve $@ in case another exception occurs
     $h->kill_kill; ## kill it gently, then brutally if need be, or just
                     ## brutally on Win32.
     die $x;
   }
  
  Timeouts and timers are I<not> checked once the subprocesses are shut
  down; they will not expire in the interval between the last valid
  process and when IPC::Run scoops up the processes' result codes, for
  instance.
  
  =head2 Spawning synchronization, child exception propagation
  
  start() pauses the parent until the child executes the command or CODE
  reference and propagates any exceptions thrown (including exec()
  failure) back to the parent.  This has several pleasant effects: any
  exceptions thrown in the child, including exec() failure, come flying
  out of start() or run() as though they had ocurred in the parent.
  
  This includes exceptions your code thrown from init subs.  In this
  example:
  
     eval {
        run \@cmd, init => sub { die "blast it! foiled again!" };
     };
     print $@;
  
  the exception "blast it! foiled again" will be thrown from the child
  process (preventing the exec()) and printed by the parent.
  
  In situations like
  
     run \@cmd1, "|", \@cmd2, "|", \@cmd3;
  
  @cmd1 will be initted and exec()ed before @cmd2, and @cmd2 before @cmd3.
  This can save time and prevent oddball errors emitted by later commands
  when earlier commands fail to execute.  Note that IPC::Run doesn't start
  any commands unless it can find the executables referenced by all
  commands.  These executables must pass both the C<-f> and C<-x> tests
  described in L<perlfunc>.
  
  Another nice effect is that init() subs can take their time doing things
  and there will be no problems caused by a parent continuing to execute
  before a child's init() routine is complete.  Say the init() routine
  needs to open a socket or a temp file that the parent wants to connect
  to; without this synchronization, the parent will need to implement a
  retry loop to wait for the child to run, since often, the parent gets a
  lot of things done before the child's first timeslice is allocated.
  
  This is also quite necessary for pseudo-tty initialization, which needs
  to take place before the parent writes to the child via pty.  Writes
  that occur before the pty is set up can get lost.
  
  A final, minor, nicety is that debugging output from the child will be
  emitted before the parent continues on, making for much clearer debugging
  output in complex situations.
  
  The only drawback I can conceive of is that the parent can't continue to
  operate while the child is being initted.  If this ever becomes a
  problem in the field, we can implement an option to avoid this behavior,
  but I don't expect it to.
  
  B<Win32>: executing CODE references isn't supported on Win32, see
  L</Win32 LIMITATIONS> for details.
  
  =head2 Syntax
  
  run(), start(), and harness() can all take a harness specification
  as input.  A harness specification is either a single string to be passed
  to the systems' shell:
  
     run "echo 'hi there'";
  
  or a list of commands, io operations, and/or timers/timeouts to execute.
  Consecutive commands must be separated by a pipe operator '|' or an '&'.
  External commands are passed in as array references, and, on systems
  supporting fork(), Perl code may be passed in as subs:
  
     run \@cmd;
     run \@cmd1, '|', \@cmd2;
     run \@cmd1, '&', \@cmd2;
     run \&sub1;
     run \&sub1, '|', \&sub2;
     run \&sub1, '&', \&sub2;
  
  '|' pipes the stdout of \@cmd1 the stdin of \@cmd2, just like a
  shell pipe.  '&' does not.  Child processes to the right of a '&'
  will have their stdin closed unless it's redirected-to.
  
  L<IPC::Run::IO> objects may be passed in as well, whether or not
  child processes are also specified:
  
     run io( "infile", ">", \$in ), io( "outfile", "<", \$in );
        
  as can L<IPC::Run::Timer> objects:
  
     run \@cmd, io( "outfile", "<", \$in ), timeout( 10 );
  
  Commands may be followed by scalar, sub, or i/o handle references for
  redirecting
  child process input & output:
  
     run \@cmd,  \undef,            \$out;
     run \@cmd,  \$in,              \$out;
     run \@cmd1, \&in, '|', \@cmd2, \*OUT;
     run \@cmd1, \*IN, '|', \@cmd2, \&out;
  
  This is known as succinct redirection syntax, since run(), start()
  and harness(), figure out which file descriptor to redirect and how.
  File descriptor 0 is presumed to be an input for
  the child process, all others are outputs.  The assumed file
  descriptor always starts at 0, unless the command is being piped to,
  in which case it starts at 1.
  
  To be explicit about your redirects, or if you need to do more complex
  things, there's also a redirection operator syntax:
  
     run \@cmd, '<', \undef, '>',  \$out;
     run \@cmd, '<', \undef, '>&', \$out_and_err;
     run(
        \@cmd1,
           '<', \$in,
        '|', \@cmd2,
           \$out
     );
  
  Operator syntax is required if you need to do something other than simple
  redirection to/from scalars or subs, like duping or closing file descriptors
  or redirecting to/from a named file.  The operators are covered in detail
  below.
  
  After each \@cmd (or \&foo), parsing begins in succinct mode and toggles to
  operator syntax mode when an operator (ie plain scalar, not a ref) is seen.
  Once in
  operator syntax mode, parsing only reverts to succinct mode when a '|' or
  '&' is seen.
  
  In succinct mode, each parameter after the \@cmd specifies what to
  do with the next highest file descriptor. These File descriptor start
  with 0 (stdin) unless stdin is being piped to (C<'|', \@cmd>), in which
  case they start with 1 (stdout).  Currently, being on the left of
  a pipe (C<\@cmd, \$out, \$err, '|'>) does I<not> cause stdout to be
  skipped, though this may change since it's not as DWIMerly as it
  could be.  Only stdin is assumed to be an
  input in succinct mode, all others are assumed to be outputs.
  
  If no piping or redirection is specified for a child, it will inherit
  the parent's open file handles as dictated by your system's
  close-on-exec behavior and the $^F flag, except that processes after a
  '&' will not inherit the parent's stdin. Also note that $^F does not
  affect file desciptors obtained via POSIX, since it only applies to
  full-fledged Perl file handles.  Such processes will have their stdin
  closed unless it has been redirected-to.
  
  If you want to close a child processes stdin, you may do any of:
  
     run \@cmd, \undef;
     run \@cmd, \"";
     run \@cmd, '<&-';
     run \@cmd, '0<&-';
  
  Redirection is done by placing redirection specifications immediately 
  after a command or child subroutine:
  
     run \@cmd1,      \$in, '|', \@cmd2,      \$out;
     run \@cmd1, '<', \$in, '|', \@cmd2, '>', \$out;
  
  If you omit the redirection operators, descriptors are counted
  starting at 0.  Descriptor 0 is assumed to be input, all others
  are outputs.  A leading '|' consumes descriptor 0, so this
  works as expected.
  
     run \@cmd1, \$in, '|', \@cmd2, \$out;
     
  The parameter following a redirection operator can be a scalar ref,
  a subroutine ref, a file name, an open filehandle, or a closed
  filehandle.
  
  If it's a scalar ref, the child reads input from or sends output to
  that variable:
  
     $in = "Hello World.\n";
     run \@cat, \$in, \$out;
     print $out;
  
  Scalars used in incremental (start()/pump()/finish()) applications are treated
  as queues: input is removed from input scalers, resulting in them dwindling
  to '', and output is appended to output scalars.  This is not true of 
  harnesses run() in batch mode.
  
  It's usually wise to append new input to be sent to the child to the input
  queue, and you'll often want to zap output queues to '' before pumping.
  
     $h = start \@cat, \$in;
     $in = "line 1\n";
     pump $h;
     $in .= "line 2\n";
     pump $h;
     $in .= "line 3\n";
     finish $h;
  
  The final call to finish() must be there: it allows the child process(es)
  to run to completion and waits for their exit values.
  
  =head1 OBSTINATE CHILDREN
  
  Interactive applications are usually optimized for human use.  This
  can help or hinder trying to interact with them through modules like
  IPC::Run.  Frequently, programs alter their behavior when they detect
  that stdin, stdout, or stderr are not connected to a tty, assuming that
  they are being run in batch mode.  Whether this helps or hurts depends
  on which optimizations change.  And there's often no way of telling
  what a program does in these areas other than trial and error and,
  occasionally, reading the source.  This includes different versions
  and implementations of the same program.
  
  All hope is not lost, however.  Most programs behave in reasonably
  tractable manners, once you figure out what it's trying to do.
  
  Here are some of the issues you might need to be aware of.
  
  =over
  
  =item *
  
  fflush()ing stdout and stderr
  
  This lets the user see stdout and stderr immediately.  Many programs
  undo this optimization if stdout is not a tty, making them harder to
  manage by things like IPC::Run.
  
  Many programs decline to fflush stdout or stderr if they do not
  detect a tty there.  Some ftp commands do this, for instance.
  
  If this happens to you, look for a way to force interactive behavior,
  like a command line switch or command.  If you can't, you will
  need to use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  false prompts
  
  Interactive programs generally do not guarantee that output from user
  commands won't contain a prompt string.  For example, your shell prompt
  might be a '$', and a file named '$' might be the only file in a directory
  listing.
  
  This can make it hard to guarantee that your output parser won't be fooled
  into early termination of results.
  
  To help work around this, you can see if the program can alter it's 
  prompt, and use something you feel is never going to occur in actual
  practice.
  
  You should also look for your prompt to be the only thing on a line:
  
     pump $h until $out =~ /^<SILLYPROMPT>\s?\z/m;
  
  (use C<(?!\n)\Z> in place of C<\z> on older perls).
  
  You can also take the approach that IPC::ChildSafe takes and emit a
  command with known output after each 'real' command you issue, then
  look for this known output.  See new_appender() and new_chunker() for
  filters that can help with this task.
  
  If it's not convenient or possibly to alter a prompt or use a known
  command/response pair, you might need to autodetect the prompt in case
  the local version of the child program is different then the one
  you tested with, or if the user has control over the look & feel of
  the prompt.
  
  =item *
  
  Refusing to accept input unless stdin is a tty.
  
  Some programs, for security reasons, will only accept certain types
  of input from a tty.  su, notable, will not prompt for a password unless
  it's connected to a tty.
  
  If this is your situation, use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  Not prompting unless connected to a tty.
  
  Some programs don't prompt unless stdin or stdout is a tty.  See if you can
  turn prompting back on.  If not, see if you can come up with a command that
  you can issue after every real command and look for it's output, as
  IPC::ChildSafe does.   There are two filters included with IPC::Run that
  can help with doing this: appender and chunker (see new_appender() and
  new_chunker()).
  
  =item *
  
  Different output format when not connected to a tty.
  
  Some commands alter their formats to ease machine parsability when they
  aren't connected to a pipe.  This is actually good, but can be surprising.
  
  =back
  
  =head1 PSEUDO TERMINALS
  
  On systems providing pseudo terminals under /dev, IPC::Run can use IO::Pty
  (available on CPAN) to provide a terminal environment to subprocesses.
  This is necessary when the subprocess really wants to think it's connected
  to a real terminal.
  
  =head2 CAVEATS
  
  Psuedo-terminals are not pipes, though they are similar.  Here are some
  differences to watch out for.
  
  =over
  
  =item Echoing
  
  Sending to stdin will cause an echo on stdout, which occurs before each
  line is passed to the child program.  There is currently no way to
  disable this, although the child process can and should disable it for
  things like passwords.
  
  =item Shutdown
  
  IPC::Run cannot close a pty until all output has been collected.  This
  means that it is not possible to send an EOF to stdin by half-closing
  the pty, as we can when using a pipe to stdin.
  
  This means that you need to send the child process an exit command or
  signal, or run() / finish() will time out.  Be careful not to expect a
  prompt after sending the exit command.
  
  =item Command line editing
  
  Some subprocesses, notable shells that depend on the user's prompt
  settings, will reissue the prompt plus the command line input so far
  once for each character.
  
  =item '>pty>' means '&>pty>', not '1>pty>'
  
  The pseudo terminal redirects both stdout and stderr unless you specify
  a file descriptor.  If you want to grab stderr separately, do this:
  
     start \@cmd, '<pty<', \$in, '>pty>', \$out, '2>', \$err;
  
  =item stdin, stdout, and stderr not inherited
  
  Child processes harnessed to a pseudo terminal have their stdin, stdout,
  and stderr completely closed before any redirection operators take
  effect.  This casts of the bonds of the controlling terminal.  This is
  not done when using pipes.
  
  Right now, this affects all children in a harness that has a pty in use,
  even if that pty would not affect a particular child.  That's a bug and
  will be fixed.  Until it is, it's best not to mix-and-match children.
  
  =back
  
  =head2 Redirection Operators
  
     Operator       SHNP   Description
     ========       ====   ===========
     <, N<          SHN    Redirects input to a child's fd N (0 assumed)
  
     >, N>          SHN    Redirects output from a child's fd N (1 assumed)
     >>, N>>        SHN    Like '>', but appends to scalars or named files
     >&, &>         SHN    Redirects stdout & stderr from a child process
  
     <pty, N<pty    S      Like '<', but uses a pseudo-tty instead of a pipe
     >pty, N>pty    S      Like '>', but uses a pseudo-tty instead of a pipe
  
     N<&M                  Dups input fd N to input fd M
     M>&N                  Dups output fd N to input fd M
     N<&-                  Closes fd N
  
     <pipe, N<pipe     P   Pipe opens H for caller to read, write, close.
     >pipe, N>pipe     P   Pipe opens H for caller to read, write, close.
                        
  'N' and 'M' are placeholders for integer file descriptor numbers.  The
  terms 'input' and 'output' are from the child process's perspective.
  
  The SHNP field indicates what parameters an operator can take:
  
     S: \$scalar or \&function references.  Filters may be used with
        these operators (and only these).
     H: \*HANDLE or IO::Handle for caller to open, and close
     N: "file name".
     P: \*HANDLE opened by IPC::Run as the parent end of a pipe, but read
        and written to and closed by the caller (like IPC::Open3).
  
  =over
  
  =item Redirecting input: [n]<, [n]<pipe
  
  You can input the child reads on file descriptor number n to come from a
  scalar variable, subroutine, file handle, or a named file.  If stdin
  is not redirected, the parent's stdin is inherited.
  
     run \@cat, \undef          ## Closes child's stdin immediately
        or die "cat returned $?"; 
  
     run \@cat, \$in;
  
     run \@cat, \<<TOHERE;
     blah
     TOHERE
  
     run \@cat, \&input;       ## Calls &input, feeding data returned
                                ## to child's.  Closes child's stdin
                                ## when undef is returned.
  
  Redirecting from named files requires you to use the input
  redirection operator:
  
     run \@cat, '<.profile';
     run \@cat, '<', '.profile';
  
     open IN, "<foo";
     run \@cat, \*IN;
     run \@cat, *IN{IO};
  
  The form used second example here is the safest,
  since filenames like "0" and "&more\n" won't confuse &run:
  
  You can't do either of
  
     run \@a, *IN;      ## INVALID
     run \@a, '<', *IN; ## BUGGY: Reads file named like "*main::A"
     
  because perl passes a scalar containing a string that
  looks like "*main::A" to &run, and &run can't tell the difference
  between that and a redirection operator or a file name.  &run guarantees
  that any scalar you pass after a redirection operator is a file name.
  
  If your child process will take input from file descriptors other
  than 0 (stdin), you can use a redirection operator with any of the
  valid input forms (scalar ref, sub ref, etc.):
  
     run \@cat, '3<', \$in3;
  
  When redirecting input from a scalar ref, the scalar ref is
  used as a queue.  This allows you to use &harness and pump() to
  feed incremental bits of input to a coprocess.  See L</Coprocesses>
  below for more information.
  
  The <pipe operator opens the write half of a pipe on the filehandle
  glob reference it takes as an argument:
  
     $h = start \@cat, '<pipe', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  Unlike the other '<' operators, IPC::Run does nothing further with
  it: you are responsible for it.  The previous example is functionally
  equivalent to:
  
     pipe( \*R, \*IN ) or die $!;
     $h = start \@cat, '<', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  This is like the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Redirecting output: [n]>, [n]>>, [n]>&[m], [n]>pipe
  
  You can redirect any output the child emits
  to a scalar variable, subroutine, file handle, or file name.  You
  can have &run truncate or append to named files or scalars.  If
  you are redirecting stdin as well, or if the command is on the
  receiving end of a pipeline ('|'), you can omit the redirection
  operator:
  
     @ls = ( 'ls' );
     run \@ls, \undef, \$out
        or die "ls returned $?"; 
  
     run \@ls, \undef, \&out;  ## Calls &out each time some output
                                ## is received from the child's 
                                ## when undef is returned.
  
     run \@ls, \undef, '2>ls.err';
     run \@ls, '2>', 'ls.err';
  
  The two parameter form guarantees that the filename
  will not be interpreted as a redirection operator:
  
     run \@ls, '>', "&more";
     run \@ls, '2>', ">foo\n";
  
  You can pass file handles you've opened for writing:
  
     open( *OUT, ">out.txt" );
     open( *ERR, ">err.txt" );
     run \@cat, \*OUT, \*ERR;
  
  Passing a scalar reference and a code reference requires a little
  more work, but allows you to capture all of the output in a scalar
  or each piece of output by a callback:
  
  These two do the same things:
  
     run( [ 'ls' ], '2>', sub { $err_out .= $_[0] } );
  
  does the same basic thing as:
  
     run( [ 'ls' ], '2>', \$err_out );
  
  The subroutine will be called each time some data is read from the child.
  
  The >pipe operator is different in concept than the other '>' operators,
  although it's syntax is similar:
  
     $h = start \@cat, $in, '>pipe', \*OUT, '2>pipe', \*ERR;
     $in = "hello world\n";
     finish $h;
     print <OUT>;
     print <ERR>;
     close OUT;
     close ERR;
  
  causes two pipe to be created, with one end attached to cat's stdout
  and stderr, respectively, and the other left open on OUT and ERR, so
  that the script can manually
  read(), select(), etc. on them.  This is like
  the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Duplicating output descriptors: >&m, n>&m
  
  This duplicates output descriptor number n (default is 1 if n is omitted)
  from descriptor number m.
  
  =item Duplicating input descriptors: <&m, n<&m
  
  This duplicates input descriptor number n (default is 0 if n is omitted)
  from descriptor number m
  
  =item Closing descriptors: <&-, 3<&-
  
  This closes descriptor number n (default is 0 if n is omitted).  The
  following commands are equivalent:
  
     run \@cmd, \undef;
     run \@cmd, '<&-';
     run \@cmd, '<in.txt', '<&-';
  
  Doing
  
     run \@cmd, \$in, '<&-';    ## SIGPIPE recipe.
  
  is dangerous: the parent will get a SIGPIPE if $in is not empty.
  
  =item Redirecting both stdout and stderr: &>, >&, &>pipe, >pipe&
  
  The following pairs of commands are equivalent:
  
     run \@cmd, '>&', \$out;       run \@cmd, '>', \$out,     '2>&1';
     run \@cmd, '>&', 'out.txt';   run \@cmd, '>', 'out.txt', '2>&1';
  
  etc.
  
  File descriptor numbers are not permitted to the left or the right of
  these operators, and the '&' may occur on either end of the operator.
  
  The '&>pipe' and '>pipe&' variants behave like the '>pipe' operator, except
  that both stdout and stderr write to the created pipe.
  
  =item Redirection Filters
  
  Both input redirections and output redirections that use scalars or
  subs as endpoints may have an arbitrary number of filter subs placed
  between them and the child process.  This is useful if you want to
  receive output in chunks, or if you want to massage each chunk of
  data sent to the child.  To use this feature, you must use operator
  syntax:
  
     run(
        \@cmd
           '<', \&in_filter_2, \&in_filter_1, $in,
           '>', \&out_filter_1, \&in_filter_2, $out,
     );
  
  This capability is not provided for IO handles or named files.
  
  Two filters are provided by IPC::Run: appender and chunker.  Because
  these may take an argument, you need to use the constructor functions
  new_appender() and new_chunker() rather than using \& syntax:
  
     run(
        \@cmd
           '<', new_appender( "\n" ), $in,
           '>', new_chunker, $out,
     );
  
  =back
  
  =head2 Just doing I/O
  
  If you just want to do I/O to a handle or file you open yourself, you
  may specify a filehandle or filename instead of a command in the harness
  specification:
  
     run io( "filename", '>', \$recv );
  
     $h = start io( $io, '>', \$recv );
  
     $h = harness \@cmd, '&', io( "file", '<', \$send );
  
  =head2 Options
  
  Options are passed in as name/value pairs:
  
     run \@cat, \$in, debug => 1;
  
  If you pass the debug option, you may want to pass it in first, so you
  can see what parsing is going on:
  
     run debug => 1, \@cat, \$in;
  
  =over
  
  =item debug
  
  Enables debugging output in parent and child.  Debugging info is emitted
  to the STDERR that was present when IPC::Run was first C<use()>ed (it's
  C<dup()>ed out of the way so that it can be redirected in children without
  having debugging output emitted on it).
  
  =back
  
  =head1 RETURN VALUES
  
  harness() and start() return a reference to an IPC::Run harness.  This is
  blessed in to the IPC::Run package, so you may make later calls to
  functions as members if you like:
  
     $h = harness( ... );
     $h->start;
     $h->pump;
     $h->finish;
  
     $h = start( .... );
     $h->pump;
     ...
  
  Of course, using method call syntax lets you deal with any IPC::Run
  subclasses that might crop up, but don't hold your breath waiting for
  any.
  
  run() and finish() return TRUE when all subcommands exit with a 0 result
  code.  B<This is the opposite of perl's system() command>.
  
  All routines raise exceptions (via die()) when error conditions are
  recognized.  A non-zero command result is not treated as an error
  condition, since some commands are tests whose results are reported 
  in their exit codes.
  
  =head1 ROUTINES
  
  =over
  
  =cut
  
  use strict;
  use Exporter ();
  use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
  BEGIN {
  	$VERSION = '0.92';
  	@ISA     = qw{ Exporter };
  
  	## We use @EXPORT for the end user's convenience: there's only one function
  	## exported, it's homonymous with the module, it's an unusual name, and
  	## it can be suppressed by "use IPC::Run ();".
  	@FILTER_IMP = qw( input_avail get_more_input );
  	@FILTERS    = qw(
  		new_appender
  		new_chunker
  		new_string_source
  		new_string_sink
  	);
  	@API        = qw(
  		run
  		harness start pump pumpable finish
  		signal kill_kill reap_nb
  		io timer timeout
  		close_terminal
  		binary
  	);
  	@EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
  	%EXPORT_TAGS = (
  		'filter_imp' => \@FILTER_IMP,
  		'all'        => \@EXPORT_OK,
  		'filters'    => \@FILTERS,
  		'api'        => \@API,
  	);
  
  }
  
  use strict;
  use IPC::Run::Debug;
  use Exporter;
  use Fcntl;
  use POSIX ();
  use Symbol;
  use Carp;
  use File::Spec ();
  use IO::Handle;
  require IPC::Run::IO;
  require IPC::Run::Timer;
  use UNIVERSAL ();
  
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  BEGIN {
     if ( Win32_MODE ) {
        eval "use IPC::Run::Win32Helper; 1;"
           or ( $@ && die ) or die "$!";
     }
     else {
        eval "use File::Basename; 1;" or die $!;
     }
  }
  
  sub input_avail();
  sub get_more_input();
  
  ###############################################################################
  
  ##
  ## Error constants, not too locale-dependant
  use vars  qw( $_EIO $_EAGAIN );
  use Errno qw(   EIO   EAGAIN );
  BEGIN {
    local $!;
    $! = EIO;    $_EIO    = qr/^$!/;
    $! = EAGAIN; $_EAGAIN = qr/^$!/;
  }
  
  ##
  ## State machine states, set in $self->{STATE}
  ##
  ## These must be in ascending order numerically
  ##
  sub _newed()    {0}
  sub _harnessed(){1}
  sub _finished() {2}   ## _finished behave almost exactly like _harnessed
  sub _started()  {3}
  
  ##
  ## Which fds have been opened in the parent.  This may have extra fds, since
  ## we aren't all that rigorous about closing these off, but that's ok.  This
  ## is used on Unixish OSs to close all fds in the child that aren't needed
  ## by that particular child.
  my %fds;
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  
  use vars qw( $cur_self );
  
  sub _debug_fd {
     return fileno STDERR unless defined $cur_self;
  
     if ( _debugging && ! defined $cur_self->{DEBUG_FD} ) {
        my $fd = select STDERR; $| = 1; select $fd;
        $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
        _debug( "debugging fd is $cur_self->{DEBUG_FD}\n" )
           if _debugging_details;
     }
  
     return fileno STDERR unless defined $cur_self->{DEBUG_FD};
  
     return $cur_self->{DEBUG_FD}
  }
  
  sub DESTROY {
     ## We absolutely do not want to do anything else here.  We are likely
     ## to be in a child process and we don't want to do things like kill_kill
     ## ourself or cause other destruction.
     my IPC::Run $self = shift;
     POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
     $self->{DEBUG_FD} = undef;
  }
  
  ##
  ## Support routines (NOT METHODS)
  ##
  my %cmd_cache;
  
  sub _search_path {
     my ( $cmd_name ) = @_;
     if ( File::Spec->file_name_is_absolute( $cmd_name ) && -x $cmd_name) {
        _debug "'", $cmd_name, "' is absolute"
           if _debugging_details;
        return $cmd_name;
     }
  
     my $dirsep =
        ( Win32_MODE
           ? '[/\\\\]'
        : $^O =~ /MacOS/
           ? ':'
        : $^O =~ /VMS/
           ? '[\[\]]'
        : '/'
        );
  
     if ( Win32_MODE
        && ( $cmd_name =~ /$dirsep/ )
  #      && ( $cmd_name !~ /\..+$/ )  ## Only run if cmd_name has no extension?
        && ( $cmd_name !~ m!\.[^\\/\.]+$! )
      ) {
  
        _debug "no extension(.exe), checking ENV{PATHEXT}"  if _debugging;
        for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
           my $name = "$cmd_name$_";
           $cmd_name = $name, last if -f $name && -x _;
        }
        _debug "cmd_name is now '$cmd_name'"  if _debugging;
     }
  
     if ( $cmd_name =~ /($dirsep)/ ) {
        _debug "'$cmd_name' contains '$1'"  if _debugging;
        croak "file not found: $cmd_name"    unless -e $cmd_name;
        croak "not a file: $cmd_name"        unless -f $cmd_name;
        croak "permission denied: $cmd_name" unless -x $cmd_name;
        return $cmd_name;
     }
  
     if ( exists $cmd_cache{$cmd_name} ) {
        _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
           if _debugging;
        return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
        _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
           if _debugging;
        delete $cmd_cache{$cmd_name};
     }
  
     my @searched_in;
  
     ## This next bit is Unix/Win32 specific, unfortunately.
     ## There's been some conversation about extending File::Spec to provide
     ## a universal interface to PATH, but I haven't seen it yet.
        my $re = Win32_MODE ? qr/;/ : qr/:/;
  
  LOOP:
     for ( split( $re, $ENV{PATH} || '', -1 ) ) {
        $_ = "." unless length $_;
        push @searched_in, $_;
  
        my $prospect = File::Spec->catfile( $_, $cmd_name );
        my @prospects;
  
        @prospects =
           ( Win32_MODE && ! ( -f $prospect && -x _ ) )
              ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
              : ( $prospect );
  
        for my $found ( @prospects ) {
           if ( -f $found && -x _ ) {
              $cmd_cache{$cmd_name} = $found;
              last LOOP;
           }
        }
     }
  
     if ( exists $cmd_cache{$cmd_name} ) {
        _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
           if _debugging_details;
        return $cmd_cache{$cmd_name};
     }
  
     croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
  }
  
  
  sub _empty($) { ! ( defined $_[0] && length $_[0] ) }
  
  ## 'safe' versions of otherwise fun things to do. See also IPC::Run::Win32Helper.
  sub _close {
     confess 'undef' unless defined $_[0];
     no strict 'refs';
     my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
     my $r = POSIX::close $fd;
     $r = $r ? '' : " ERROR $!";
     delete $fds{$fd};
     _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
  }
  
  sub _dup {
     confess 'undef' unless defined $_[0];
     my $r = POSIX::dup( $_[0] );
     croak "$!: dup( $_[0] )" unless defined $r;
     $r = 0 if $r eq '0 but true';
     _debug "dup( $_[0] ) = $r" if _debugging_details;
     $fds{$r} = 1;
     return $r;
  }
  
  
  sub _dup2_rudely {
     confess 'undef' unless defined $_[0] && defined $_[1];
     my $r = POSIX::dup2( $_[0], $_[1] );
     croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
     $r = 0 if $r eq '0 but true';
     _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
     $fds{$r} = 1;
     return $r;
  }
  
  sub _exec {
     confess 'undef passed' if grep !defined, @_;
  #   exec @_ or croak "$!: exec( " . join( ', ', @_ ) . " )";
     _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
  
  #   {
  ## Commented out since we don't call this on Win32.
  #      # This works around the bug where 5.6.1 complains
  #      # "Can't exec ...: No error" after an exec on NT, where
  #      # exec() is simulated and actually returns in Perl's C
  #      # code, though Perl's &exec does not...
  #      no warnings "exec";
  #
  #      # Just in case the no warnings workaround
  #      # stops beign a workaround, we don't want
  #      # old values of $! causing spurious strerr()
  #      # messages to appear in the "Can't exec" message
  #      undef $!;
        exec @_;
  #   }
  #   croak "$!: exec( " . join( ', ', map "'$_'", @_ ) . " )";
      ## Fall through so $! can be reported to parent.
  }
  
  
  sub _sysopen {
     confess 'undef' unless defined $_[0] && defined $_[1];
  _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
  sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
  sprintf( "O_RDWR=0x%02x ", O_RDWR ),
  sprintf( "O_TRUNC=0x%02x ", O_TRUNC),
  sprintf( "O_CREAT=0x%02x ", O_CREAT),
  sprintf( "O_APPEND=0x%02x ", O_APPEND),
  if _debugging_details;
     my $r = POSIX::open( $_[0], $_[1], 0644 );
     croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
     _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
        if _debugging_data;
     $fds{$r} = 1;
     return $r;
  }
  
  sub _pipe {
     ## Normal, blocking write for pipes that we read and the child writes,
     ## since most children expect writes to stdout to block rather than
     ## do a partial write.
     my ( $r, $w ) = POSIX::pipe;
     croak "$!: pipe()" unless defined $r;
     _debug "pipe() = ( $r, $w ) " if _debugging_details;
     $fds{$r} = $fds{$w} = 1;
     return ( $r, $w );
  }
  
  sub _pipe_nb {
     ## For pipes that we write, unblock the write side, so we can fill a buffer
     ## and continue to select().
     ## Contributed by Borislav Deianov <borislav@ensim.com>, with minor
     ## bugfix on fcntl result by me.
     local ( *R, *W );
     my $f = pipe( R, W );
     croak "$!: pipe()" unless defined $f;
     my ( $r, $w ) = ( fileno R, fileno W );
     _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
     unless ( Win32_MODE ) {
        ## POSIX::fcntl doesn't take fd numbers, so gotta use Perl's and
        ## then _dup the originals (which get closed on leaving this block)
        my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
        croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
        _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
     }
     ( $r, $w ) = ( _dup( $r ), _dup( $w ) );
     _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
     return ( $r, $w );
  }
  
  sub _pty {
     require IO::Pty;
     my $pty = IO::Pty->new();
     croak "$!: pty ()" unless $pty;
     $pty->autoflush();
     $pty->blocking( 0 ) or croak "$!: pty->blocking ( 0 )";
     _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
        if _debugging_details;
     $fds{$pty->fileno} = $fds{$pty->slave->fileno} = 1;
     return $pty;
  }
  
  
  sub _read {
     confess 'undef' unless defined $_[0];
     my $s  = '';
     my $r = POSIX::read( $_[0], $s, 10_000 );
     croak "$!: read( $_[0] )" if not($r) and $! != POSIX::EINTR;
     $r ||= 0;
     _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
     return $s;
  }
  
  
  ## A METHOD, not a function.
  sub _spawn {
     my IPC::Run $self = shift;
     my ( $kid ) = @_;
  
     _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
     my $sync_reader_fd;
     ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
     $kid->{PID} = fork();
     croak "$! during fork" unless defined $kid->{PID};
  
     unless ( $kid->{PID} ) {
        ## _do_kid_and_exit closes sync_reader_fd since it closes all unwanted and
        ## unloved fds.
        $self->_do_kid_and_exit( $kid );
     }
     _debug "fork() = ", $kid->{PID} if _debugging_details;
  
     ## Wait for kid to get to it's exec() and see if it fails.
     _close $self->{SYNC_WRITER_FD};
     my $sync_pulse = _read $sync_reader_fd;
     _close $sync_reader_fd;
  
     if ( ! defined $sync_pulse || length $sync_pulse ) {
        if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
  	 $kid->{RESULT} = $?;
        }
        else {
  	 $kid->{RESULT} = -1;
        }
        $sync_pulse =
           "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
  	 unless length $sync_pulse;
        croak $sync_pulse;
     }
     return $kid->{PID};
  
  ## Wait for pty to get set up.  This is a hack until we get synchronous
  ## selects.
  if ( keys %{$self->{PTYS}} && $IO::Pty::VERSION < 0.9 ) {
  _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
  sleep 1;
  }
  }
  
  
  sub _write {
     confess 'undef' unless defined $_[0] && defined $_[1];
     my $r = POSIX::write( $_[0], $_[1], length $_[1] );
     croak "$!: write( $_[0], '$_[1]' )" unless $r;
     _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
     return $r;
  }
  
  =pod
  
  =over
  
  =item run
  
  Run takes a harness or harness specification and runs it, pumping
  all input to the child(ren), closing the input pipes when no more
  input is available, collecting all output that arrives, until the
  pipes delivering output are closed, then waiting for the children to
  exit and reaping their result codes.
  
  You may think of C<run( ... )> as being like 
  
     start( ... )->finish();
  
  , though there is one subtle difference: run() does not
  set \$input_scalars to '' like finish() does.  If an exception is thrown
  from run(), all children will be killed off "gently", and then "annihilated"
  if they do not go gently (in to that dark night. sorry).
  
  If any exceptions are thrown, this does a L</kill_kill> before propogating
  them.
  
  =cut
  
  use vars qw( $in_run );  ## No, not Enron;)
  
  sub run {
     local $in_run = 1;  ## Allow run()-only optimizations.
     my IPC::Run $self = start( @_ );
     my $r = eval {
        $self->{clear_ins} = 0;
        $self->finish;
     };
     if ( $@ ) {
        my $x = $@;
        $self->kill_kill;
        die $x;
     }
     return $r;
  }
  
  =pod
  
  =item signal
  
     ## To send it a specific signal by name ("USR1"):
     signal $h, "USR1";
     $h->signal ( "USR1" );
  
  If $signal is provided and defined, sends a signal to all child processes.  Try
  not to send numeric signals, use C<"KILL"> instead of C<9>, for instance.
  Numeric signals aren't portable.
  
  Throws an exception if $signal is undef.
  
  This will I<not> clean up the harness, C<finish> it if you kill it.
  
  Normally TERM kills a process gracefully (this is what the command line utility
  C<kill> does by default), INT is sent by one of the keys C<^C>, C<Backspace> or
  C<E<lt>DelE<gt>>, and C<QUIT> is used to kill a process and make it coredump.
  
  The C<HUP> signal is often used to get a process to "restart", rereading 
  config files, and C<USR1> and C<USR2> for really application-specific things.
  
  Often, running C<kill -l> (that's a lower case "L") on the command line will
  list the signals present on your operating system.
  
  B<WARNING>: The signal subsystem is not at all portable.  We *may* offer
  to simulate C<TERM> and C<KILL> on some operating systems, submit code
  to me if you want this.
  
  B<WARNING 2>: Up to and including perl v5.6.1, doing almost anything in a
  signal handler could be dangerous.  The most safe code avoids all
  mallocs and system calls, usually by preallocating a flag before
  entering the signal handler, altering the flag's value in the
  handler, and responding to the changed value in the main system:
  
     my $got_usr1 = 0;
     sub usr1_handler { ++$got_signal }
  
     $SIG{USR1} = \&usr1_handler;
     while () { sleep 1; print "GOT IT" while $got_usr1--; }
  
  Even this approach is perilous if ++ and -- aren't atomic on your system
  (I've never heard of this on any modern CPU large enough to run perl).
  
  =cut
  
  sub signal {
     my IPC::Run $self = shift;
  
     local $cur_self = $self;
  
     $self->_kill_kill_kill_pussycat_kill unless @_;
  
     Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
  
     my ( $signal ) = @_;
     croak "Undefined signal passed to signal" unless defined $signal;
     for ( grep $_->{PID} && ! defined $_->{RESULT}, @{$self->{KIDS}} ) {
        _debug "sending $signal to $_->{PID}"
           if _debugging;
        kill $signal, $_->{PID}
           or _debugging && _debug "$! sending $signal to $_->{PID}";
     }
     
     return;
  }
  
  =pod
  
  =item kill_kill
  
     ## To kill off a process:
     $h->kill_kill;
     kill_kill $h;
  
     ## To specify the grace period other than 30 seconds:
     kill_kill $h, grace => 5;
  
     ## To send QUIT instead of KILL if a process refuses to die:
     kill_kill $h, coup_d_grace => "QUIT";
  
  Sends a C<TERM>, waits for all children to exit for up to 30 seconds, then
  sends a C<KILL> to any that survived the C<TERM>.
  
  Will wait for up to 30 more seconds for the OS to successfully C<KILL> the
  processes.
  
  The 30 seconds may be overridden by setting the C<grace> option, this
  overrides both timers.
  
  The harness is then cleaned up.
  
  The doubled name indicates that this function may kill again and avoids
  colliding with the core Perl C<kill> function.
  
  Returns a 1 if the C<TERM> was sufficient, or a 0 if C<KILL> was 
  required.  Throws an exception if C<KILL> did not permit the children
  to be reaped.
  
  B<NOTE>: The grace period is actually up to 1 second longer than that
  given.  This is because the granularity of C<time> is 1 second.  Let me
  know if you need finer granularity, we can leverage Time::HiRes here.
  
  B<Win32>: Win32 does not know how to send real signals, so C<TERM> is
  a full-force kill on Win32.  Thus all talk of grace periods, etc. do
  not apply to Win32.
  
  =cut
  
  sub kill_kill {
     my IPC::Run $self = shift;
  
     my %options = @_;
     my $grace = $options{grace};
     $grace = 30 unless defined $grace;
     ++$grace; ## Make grace time a _minimum_
  
     my $coup_d_grace = $options{coup_d_grace};
     $coup_d_grace = "KILL" unless defined $coup_d_grace;
  
     delete $options{$_} for qw( grace coup_d_grace );
     Carp::cluck "Ignoring unknown options for kill_kill: ",
         join " ",keys %options
         if keys %options;
  
     $self->signal( "TERM" );
  
     my $quitting_time = time + $grace;
     my $delay = 0.01;
     my $accum_delay;
  
     my $have_killed_before;
  
     while () {
        ## delay first to yeild to other processes
        select undef, undef, undef, $delay;
        $accum_delay += $delay;
  
        $self->reap_nb;
        last unless $self->_running_kids;
  
        if ( $accum_delay >= $grace*0.8 ) {
           ## No point in checking until delay has grown some.
           if ( time >= $quitting_time ) {
              if ( ! $have_killed_before ) {
                 $self->signal( $coup_d_grace );
                 $have_killed_before = 1;
                 $quitting_time += $grace;
                 $delay = 0.01;
                 $accum_delay = 0;
                 next;
              }
              croak "Unable to reap all children, even after KILLing them"
           }
        }
  
        $delay *= 2;
        $delay = 0.5 if $delay >= 0.5;
     }
  
     $self->_cleanup;
     return $have_killed_before;
  }
  
  =pod
  
  =item harness
  
  Takes a harness specification and returns a harness.  This harness is
  blessed in to IPC::Run, allowing you to use method call syntax for
  run(), start(), et al if you like.
  
  harness() is provided so that you can pre-build harnesses if you
  would like to, but it's not required..
  
  You may proceed to run(), start() or pump() after calling harness() (pump()
  calls start() if need be).  Alternatively, you may pass your
  harness specification to run() or start() and let them harness() for
  you.  You can't pass harness specifications to pump(), though.
  
  =cut
  
  ##
  ## Notes: I've avoided handling a scalar that doesn't look like an
  ## opcode as a here document or as a filename, though I could DWIM
  ## those.  I'm not sure that the advantages outweight the danger when
  ## the DWIMer guesses wrong.
  ##
  ## TODO: allow user to spec default shell. Hmm, globally, in the
  ## lexical scope hash, or per instance?  'Course they can do that
  ## now by using a [...] to hold the command.
  ##
  my $harness_id = 0;
  sub harness {
     my $options;
     if ( @_ && ref $_[-1] eq 'HASH' ) {
        $options = pop;
        require Data::Dumper;
        carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper( $options );
     }
  
  #   local $IPC::Run::debug = $options->{debug}
  #      if $options && defined $options->{debug};
  
     my @args;
     if ( @_ == 1 && ! ref $_[0] ) {
        if ( Win32_MODE ) {
           my $command = $ENV{ComSpec} || 'cmd';
           @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
        }
        else {
           @args = ( [ qw( sh -c ), @_ ] );
        }
     }
     elsif ( @_ > 1 && ! grep ref $_, @_ ) {
        @args = ( [ @_ ] );
     }
     else {
        @args = @_;
     }
  
     my @errs;               # Accum errors, emit them when done.
  
     my $succinct;           # set if no redir ops are required yet.  Cleared
                              # if an op is seen.
  
     my $cur_kid;            # references kid or handle being parsed
  
     my $assumed_fd    = 0;  # fd to assume in succinct mode (no redir ops)
     my $handle_num    = 0;  # 1... is which handle we're parsing
  
     my IPC::Run $self = bless {}, __PACKAGE__;
  
     local $cur_self = $self;
  
     $self->{ID}    = ++$harness_id;
     $self->{IOS}   = [];
     $self->{KIDS}  = [];
     $self->{PIPES} = [];
     $self->{PTYS}  = {};
     $self->{STATE} = _newed;
  
     if ( $options ) {
        $self->{$_} = $options->{$_}
           for keys %$options;
     }
  
     _debug "****** harnessing *****" if _debugging;
  
     my $first_parse;
     local $_;
     my $arg_count = @args;
     while ( @args ) { for ( shift @args ) {
        eval {
           $first_parse = 1;
           _debug(
              "parsing ",
              defined $_
                 ? ref $_ eq 'ARRAY'
                    ? ( '[ ', join( ', ', map "'$_'", @$_ ), ' ]' )
                    : ( ref $_
                       || ( length $_ < 50
                             ? "'$_'"
                             : join( '', "'", substr( $_, 0, 10 ), "...'" )
                          )
                    )
                 : '<undef>'
           ) if _debugging;
  
        REPARSE:
           if ( ref eq 'ARRAY' || ( ! $cur_kid && ref eq 'CODE' ) ) {
              croak "Process control symbol ('|', '&') missing" if $cur_kid;
              croak "Can't spawn a subroutine on Win32"
  	       if Win32_MODE && ref eq "CODE";
              $cur_kid = {
                 TYPE   => 'cmd',
                 VAL    => $_,
                 NUM    => @{$self->{KIDS}} + 1,
                 OPS    => [],
                 PID    => '',
                 RESULT => undef,
              };
              push @{$self->{KIDS}}, $cur_kid;
              $succinct = 1;
           }
  
           elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
              push @{$self->{IOS}}, $_;
              $cur_kid = undef;
              $succinct = 1;
           }
           
           elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
              push @{$self->{TIMERS}}, $_;
              $cur_kid = undef;
              $succinct = 1;
           }
           
           elsif ( /^(\d*)>&(\d+)$/ ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'dup',
                 KFD1 => $2,
                 KFD2 => length $1 ? $1 : 1,
              };
              _debug "redirect operators now required" if _debugging_details;
              $succinct = ! $first_parse;
           }
  
           elsif ( /^(\d*)<&(\d+)$/ ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'dup',
                 KFD1 => $2,
                 KFD2 => length $1 ? $1 : 0,
              };
              $succinct = ! $first_parse;
           }
  
           elsif ( /^(\d*)<&-$/ ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'close',
                 KFD  => length $1 ? $1 : 0,
              };
              $succinct = ! $first_parse;
           }
  
           elsif (
                 /^(\d*) (<pipe)()            ()  ()  $/x
              || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
              || /^(\d*) (<)    ()            ()  (.*)$/x
           ) {
              croak "No command before '$_'" unless $cur_kid;
  
              $succinct = ! $first_parse;
  
              my $type = $2 . $4;
  
              my $kfd = length $1 ? $1 : 0;
  
              my $pty_id;
              if ( $type eq '<pty<' ) {
                 $pty_id = length $3 ? $3 : '0';
                 ## do the require here to cause early error reporting
                 require IO::Pty;
                 ## Just flag the pyt's existence for now.  It'll be
                 ## converted to a real IO::Pty by _open_pipes.
                 $self->{PTYS}->{$pty_id} = undef;
              }
  
              my $source = $5;
  
              my @filters;
              my $binmode;
  
              unless ( length $source ) {
                 if ( ! $succinct ) {
                    while ( @args > 1
                        && (
                           ( ref $args[1] && ! UNIVERSAL::isa $args[1], "IPC::Run::Timer" )
                           || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter"
                        )
                    ) {
                       if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                          $binmode = shift( @args )->();
                       }
                       else {
                          push @filters, shift @args
                       }
                    }
                 }
                 $source = shift @args;
                 croak "'$_' missing a source" if _empty $source;
  
                 _debug(
                    'Kid ', $cur_kid->{NUM}, "'s input fd ", $kfd,
                    ' has ', scalar( @filters ), ' filters.'
                 ) if _debugging_details && @filters;
              };
  
              my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal(
                 $type, $kfd, $pty_id, $source, $binmode, @filters
              );
  
              if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
                 && $type !~ /^<p(ty<|ipe)$/
              ) {
  	       _debug "setting DONT_CLOSE" if _debugging_details;
                 $pipe->{DONT_CLOSE} = 1; ## this FD is not closed by us.
  	       _dont_inherit( $source ) if Win32_MODE;
              }
  
              push @{$cur_kid->{OPS}}, $pipe;
        }
  
           elsif ( /^()   (>>?)  (&)     ()      (.*)$/x
              ||   /^()   (&)    (>pipe) ()      ()  $/x 
              ||   /^()   (>pipe)(&)     ()      ()  $/x 
              ||   /^(\d*)()     (>pipe) ()      ()  $/x
              ||   /^()   (&)    (>pty)  ( \w*)> ()  $/x 
  ## TODO:    ||   /^()   (>pty) (\d*)> (&) ()  $/x 
              ||   /^(\d*)()     (>pty)  ( \w*)> ()  $/x
              ||   /^()   (&)    (>>?)   ()      (.*)$/x 
              ||   /^(\d*)()     (>>?)   ()      (.*)$/x
           ) {
              croak "No command before '$_'" unless $cur_kid;
  
              $succinct = ! $first_parse;
  
              my $type = (
                 $2 eq '>pipe' || $3 eq '>pipe'
                    ? '>pipe'
                    : $2 eq '>pty' || $3 eq '>pty'
                       ? '>pty>'
                       : '>'
              );
              my $kfd = length $1 ? $1 : 1;
              my $trunc = ! ( $2 eq '>>' || $3 eq '>>' );
              my $pty_id = (
                 $2 eq '>pty' || $3 eq '>pty'
                    ? length $4 ? $4 : 0
                    : undef
              );
  
              my $stderr_too =
                    $2 eq '&'
                 || $3 eq '&'
                 || ( ! length $1 && substr( $type, 0, 4 ) eq '>pty' );
  
              my $dest = $5;
              my @filters;
              my $binmode = 0;
              unless ( length $dest ) {
                 if ( ! $succinct ) {
                    ## unshift...shift: '>' filters source...sink left...right
                    while ( @args > 1
                       && ( 
                          ( ref $args[1] && !  UNIVERSAL::isa $args[1], "IPC::Run::Timer" )
                          || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter"
                       )
                    ) {
                       if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                          $binmode = shift( @args )->();
                       }
                       else {
                          unshift @filters, shift @args;
                       }
                    }
                 }
  
                 $dest = shift @args;
  
                 _debug(
                    'Kid ', $cur_kid->{NUM}, "'s output fd ", $kfd,
                    ' has ', scalar( @filters ), ' filters.'
                 ) if _debugging_details && @filters;
  
                 if ( $type eq '>pty>' ) {
                    ## do the require here to cause early error reporting
                    require IO::Pty;
                    ## Just flag the pyt's existence for now.  _open_pipes()
                    ## will new an IO::Pty for each key.
                    $self->{PTYS}->{$pty_id} = undef;
                 }
              }
  
              croak "'$_' missing a destination" if _empty $dest;
              my $pipe = IPC::Run::IO->_new_internal(
                 $type, $kfd, $pty_id, $dest, $binmode, @filters
              );
              $pipe->{TRUNC} = $trunc;
  
              if (  ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
                 && $type !~ /^>(pty>|pipe)$/
              ) {
  	       _debug "setting DONT_CLOSE" if _debugging_details;
                 $pipe->{DONT_CLOSE} = 1; ## this FD is not closed by us.
              }
              push @{$cur_kid->{OPS}}, $pipe;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'dup',
                 KFD1 => 1,
                 KFD2 => 2,
              } if $stderr_too;
           }
  
           elsif ( $_ eq "|" ) {
              croak "No command before '$_'" unless $cur_kid;
              unshift @{$cur_kid->{OPS}}, {
                 TYPE => '|',
                 KFD  => 1,
              };
              $succinct   = 1;
              $assumed_fd = 1;
              $cur_kid    = undef;
           }
  
           elsif ( $_ eq "&" ) {
              croak "No command before '$_'" unless $cur_kid;
              unshift @{$cur_kid->{OPS}}, {
                 TYPE => 'close',
                 KFD  => 0,
              };
              $succinct   = 1;
              $assumed_fd = 0;
              $cur_kid    = undef;
           }
  
           elsif ( $_ eq 'init' ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'init',
                 SUB  => shift @args,
              };
           }
  
           elsif ( ! ref $_ ) {
              $self->{$_} = shift @args;
           }
  
           elsif ( $_ eq 'init' ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'init',
                 SUB  => shift @args,
              };
           }
  
           elsif ( $succinct && $first_parse ) {
              ## It's not an opcode, and no explicit opcodes have been
              ## seen yet, so assume it's a file name.
              unshift @args, $_;
              if ( ! $assumed_fd ) {
                 $_ = "$assumed_fd<",
              }
              else {
                 $_ = "$assumed_fd>",
              }
              _debug "assuming '", $_, "'" if _debugging_details;
              ++$assumed_fd;
              $first_parse = 0;
              goto REPARSE;
           }
  
           else {
              croak join( 
                 '',
                 'Unexpected ',
                 ( ref() ? $_ : 'scalar' ),
                 ' in harness() parameter ',
                 $arg_count - @args
              );
           }
        };
        if ( $@ ) {
           push @errs, $@;
           _debug 'caught ', $@ if _debugging;
        }
     } }
  
     die join( '', @errs ) if @errs;
  
  
     $self->{STATE} = _harnessed;
  #   $self->timeout( $options->{timeout} ) if exists $options->{timeout};
     return $self;
  }
  
  
  sub _open_pipes {
     my IPC::Run $self = shift;
  
     my @errs;
  
     my @close_on_fail;
  
     ## When a pipe character is seen, a pipe is created.  $pipe_read_fd holds
     ## the dangling read end of the pipe until we get to the next process.
     my $pipe_read_fd;
  
     ## Output descriptors for the last command are shared by all children.
     ## @output_fds_accum accumulates the current set of output fds.
     my @output_fds_accum;
  
     for ( sort keys %{$self->{PTYS}} ) {
        _debug "opening pty '", $_, "'" if _debugging_details;
        my $pty = _pty;
        $self->{PTYS}->{$_} = $pty;
     }
  
     for ( @{$self->{IOS}} ) {
        eval { $_->init; };
        if ( $@ ) {
           push @errs, $@;
           _debug 'caught ', $@ if _debugging;
        }
        else {
           push @close_on_fail, $_;
        }
     }
  
     ## Loop through the kids and their OPS, interpreting any that require
     ## parent-side actions.
     for my $kid ( @{$self->{KIDS}} ) {
        unless ( ref $kid->{VAL} eq 'CODE' ) {
           $kid->{PATH} = _search_path $kid->{VAL}->[0];
        }
        if ( defined $pipe_read_fd ) {
  	 _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
  	    if _debugging_details;
           unshift @{$kid->{OPS}}, {
              TYPE => 'PIPE',  ## Prevent next loop from triggering on this
              KFD  => 0,
              TFD  => $pipe_read_fd,
           };
           $pipe_read_fd = undef;
        }
        @output_fds_accum = ();
        for my $op ( @{$kid->{OPS}} ) {
  #         next if $op->{IS_DEBUG};
           my $ok = eval {
              if ( $op->{TYPE} eq '<' ) {
                 my $source = $op->{SOURCE};
  	       if ( ! ref $source ) {
  		  _debug(
  		     "kid ", $kid->{NUM}, " to read ", $op->{KFD},
  		     " from '" .  $source, "' (read only)"
  		  ) if _debugging_details;
  		  croak "simulated open failure"
  		     if $self->{_simulate_open_failure};
  		  $op->{TFD} = _sysopen( $source, O_RDONLY );
  		  push @close_on_fail, $op->{TFD};
  	       }
  	       elsif ( UNIVERSAL::isa( $source, 'GLOB' )
  		  ||   UNIVERSAL::isa( $source, 'IO::Handle' )
  	       ) {
  		  croak
  		     "Unopened filehandle in input redirect for $op->{KFD}"
  		     unless defined fileno $source;
  		  $op->{TFD} = fileno $source;
  		  _debug(
  		     "kid ", $kid->{NUM}, " to read ", $op->{KFD},
  		     " from fd ", $op->{TFD}
  		  ) if _debugging_details;
  	       }
  	       elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
  		  _debug(
  		     "kid ", $kid->{NUM}, " to read ", $op->{KFD},
  		     " from SCALAR"
  		  ) if _debugging_details;
  
  		  $op->open_pipe( $self->_debug_fd );
  		  push @close_on_fail, $op->{KFD}, $op->{FD};
  
  		  my $s = '';
  		  $op->{KIN_REF} = \$s;
  	       }
  	       elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
  		  _debug(
  		     'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE'
  		  ) if _debugging_details;
  		  
  		  $op->open_pipe( $self->_debug_fd );
  		  push @close_on_fail, $op->{KFD}, $op->{FD};
  		  
  		  my $s = '';
  		  $op->{KIN_REF} = \$s;
  	       }
  	       else {
  		  croak(
  		     "'"
  		     . ref( $source )
  		     . "' not allowed as a source for input redirection"
  		  );
  	       }
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '<pipe' ) {
                 _debug(
                    'kid to read ', $op->{KFD},
                    ' from a pipe IPC::Run opens and returns',
                 ) if _debugging_details;
  
                 my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
  	       _debug "caller will write to ", fileno $op->{SOURCE}
  	          if _debugging_details;
  
                 $op->{TFD}    = $r;
  	       $op->{FD}     = undef; # we don't manage this fd
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '<pty<' ) {
                 _debug(
                    'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
                 ) if _debugging_details;
                 
                 for my $source ( $op->{SOURCE} ) {
                    if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                       _debug(
                          "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                          " from SCALAR via pty '", $op->{PTY_ID}, "'"
                       ) if _debugging_details;
  
                       my $s = '';
                       $op->{KIN_REF} = \$s;
                    }
                    elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                       _debug(
                          "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                          " from CODE via pty '", $op->{PTY_ID}, "'"
                       ) if _debugging_details;
                       my $s = '';
                       $op->{KIN_REF} = \$s;
                    }
                    else {
                       croak(
                          "'"
                          . ref( $source )
                          . "' not allowed as a source for '<pty<' redirection"
                       );
                    }
                 }
                 $op->{FD} = $self->{PTYS}->{$op->{PTY_ID}}->fileno;
                 $op->{TFD} = undef; # The fd isn't known until after fork().
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '>' ) {
                 ## N> output redirection.
                 my $dest = $op->{DEST};
                 if ( ! ref $dest ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                       " to '", $dest, "' (write only, create, ",
                       ( $op->{TRUNC} ? 'truncate' : 'append' ),
                       ")"
                    ) if _debugging_details;
                    croak "simulated open failure"
                       if $self->{_simulate_open_failure};
                    $op->{TFD} = _sysopen(
                       $dest,
                       ( O_WRONLY
                       | O_CREAT 
                       | ( $op->{TRUNC} ? O_TRUNC : O_APPEND )
                       )
                    );
  		  if ( Win32_MODE ) {
  		     ## I have no idea why this is needed to make the current
  		     ## file position survive the gyrations TFD must go 
  		     ## through...
  		     POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
  		  }
                    push @close_on_fail, $op->{TFD};
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
                    croak(
                     "Unopened filehandle in output redirect, command $kid->{NUM}"
                    ) unless defined fileno $dest;
                    ## Turn on autoflush, mostly just to flush out
                    ## existing output.
                    my $old_fh = select( $dest ); $| = 1; select( $old_fh );
                    $op->{TFD} = fileno $dest;
                    _debug(
                       'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD}
                    ) if _debugging_details;
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR"
                    ) if _debugging_details;
  
  		  $op->open_pipe( $self->_debug_fd );
                    push @close_on_fail, $op->{FD}, $op->{TFD};
                    $$dest = '' if $op->{TRUNC};
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                    _debug(
                       "kid $kid->{NUM} to write $op->{KFD} to CODE"
                    ) if _debugging_details;
  
  		  $op->open_pipe( $self->_debug_fd );
                    push @close_on_fail, $op->{FD}, $op->{TFD};
                 }
                 else {
                    croak(
                       "'"
                       . ref( $dest )
                       . "' not allowed as a sink for output redirection"
                    );
                 }
                 $output_fds_accum[$op->{KFD}] = $op;
                 $op->_init_filters;
              }
  
              elsif ( $op->{TYPE} eq '>pipe' ) {
                 ## N> output redirection to a pipe we open, but don't select()
                 ## on.
                 _debug(
                    "kid ", $kid->{NUM}, " to write ", $op->{KFD},
  		  ' to a pipe IPC::Run opens and returns'
                 ) if _debugging_details;
  
                 my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
  	       _debug "caller will read from ", fileno $op->{DEST}
  	          if _debugging_details;
  
                 $op->{TFD} = $w;
  	       $op->{FD}  = undef; # we don't manage this fd
                 $op->_init_filters;
  
                 $output_fds_accum[$op->{KFD}] = $op;
              }
              elsif ( $op->{TYPE} eq '>pty>' ) {
                 my $dest = $op->{DEST};
                 if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                       " to SCALAR via pty '", $op->{PTY_ID}, "'"
                 ) if _debugging_details;
  
                    $$dest = '' if $op->{TRUNC};
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                       " to CODE via pty '", $op->{PTY_ID}, "'"
                    ) if _debugging_details;
                 }
                 else {
                    croak(
                       "'"
                       . ref( $dest )
                       . "' not allowed as a sink for output redirection"
                    );
                 }
  
                 $op->{FD} = $self->{PTYS}->{$op->{PTY_ID}}->fileno;
                 $op->{TFD} = undef; # The fd isn't known until after fork().
                 $output_fds_accum[$op->{KFD}] = $op;
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '|' ) {
                 _debug(
                    "pipelining $kid->{NUM} and "
                    . ( $kid->{NUM} + 1 )
                 ) if _debugging_details;
                 ( $pipe_read_fd, $op->{TFD} ) = _pipe;
  	       if ( Win32_MODE ) {
  		  _dont_inherit( $pipe_read_fd );
  		  _dont_inherit( $op->{TFD} );
  	       }
                 @output_fds_accum = ();
              }
              elsif ( $op->{TYPE} eq '&' ) {
                 @output_fds_accum = ();
              } # end if $op->{TYPE} tree
  	    1;
  	 }; # end eval
  	 unless ( $ok ) {
  	    push @errs, $@;
  	    _debug 'caught ', $@ if _debugging;
  	 }
        } # end for ( OPS }
     }
  
     if ( @errs ) {
        for ( @close_on_fail ) {
           _close( $_ );
           $_ = undef;
        }
        for ( keys %{$self->{PTYS}} ) {
           next unless $self->{PTYS}->{$_};
           close $self->{PTYS}->{$_};
           $self->{PTYS}->{$_} = undef;
        }
        die join( '', @errs )
     }
  
     ## give all but the last child all of the output file descriptors
     ## These will be reopened (and thus rendered useless) if the child
     ## dup2s on to these descriptors, since we unshift these.  This way
     ## each process emits output to the same file descriptors that the
     ## last child will write to.  This is probably not quite correct,
     ## since each child should write to the file descriptors inherited
     ## from the parent.
     ## TODO: fix the inheritance of output file descriptors.
     ## NOTE: This sharing of OPS among kids means that we can't easily put
     ## a kid number in each OPS structure to ping the kid when all ops
     ## have closed (when $self->{PIPES} has emptied).  This means that we
     ## need to scan the KIDS whenever @{$self->{PIPES}} is empty to see
     ## if there any of them are still alive.
     for ( my $num = 0; $num < $#{$self->{KIDS}}; ++$num ) {
        for ( reverse @output_fds_accum ) {
           next unless defined $_;
           _debug(
              'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
              ' to ', ref $_->{DEST}
           ) if _debugging_details;
           unshift @{$self->{KIDS}->[$num]->{OPS}}, $_;
        }
     }
  
     ## Open the debug pipe if we need it
     ## Create the list of PIPES we need to scan and the bit vectors needed by
     ## select().  Do this first so that _cleanup can _clobber() them if an
     ## exception occurs.
     @{$self->{PIPES}} = ();
     $self->{RIN} = '';
     $self->{WIN} = '';
     $self->{EIN} = '';
     ## PIN is a vec()tor that indicates who's paused.
     $self->{PIN} = '';
     for my $kid ( @{$self->{KIDS}} ) {
        for ( @{$kid->{OPS}} ) {
           if ( defined $_->{FD} ) {
              _debug(
                 'kid ', $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
                 ' is my ', $_->{FD}
              ) if _debugging_details;
              vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
  #	    vec( $self->{EIN}, $_->{FD}, 1 ) = 1;
              push @{$self->{PIPES}}, $_;
           }
        }
     }
  
     for my $io ( @{$self->{IOS}} ) {
        my $fd = $io->fileno;
        vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
        vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
  #      vec( $self->{EIN}, $fd, 1 ) = 1;
        push @{$self->{PIPES}}, $io;
     }
  
     ## Put filters on the end of the filter chains to read & write the pipes.
     ## Clear pipe states
     for my $pipe ( @{$self->{PIPES}} ) {
        $pipe->{SOURCE_EMPTY} = 0;
        $pipe->{PAUSED} = 0;
        if ( $pipe->{TYPE} =~ /^>/ ) {
           my $pipe_reader = sub {
              my ( undef, $out_ref ) = @_;
  
              return undef unless defined $pipe->{FD};
              return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
  
              vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
  
              _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
              my $in = eval { _read( $pipe->{FD} ) };
              if ( $@ ) {
                 $in = '';
                 ## IO::Pty throws the Input/output error if the kid dies.
  	       ## read() throws the bad file descriptor message if the
  	       ## kid dies on Win32.
                 die $@ unless
  	          $@ =~ $_EIO ||
  		  ($@ =~ /input or output/ && $^O =~ /aix/) 
  		  || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
              }
  
              unless ( length $in ) {
                 $self->_clobber( $pipe );
                 return undef;
              }
  
              ## Protect the position so /.../g matches may be used.
              my $pos = pos $$out_ref;
              $$out_ref .= $in;
              pos( $$out_ref ) = $pos;
              return 1;
           };
           ## Input filters are the last filters
           push @{$pipe->{FILTERS}}, $pipe_reader;
           push @{$self->{TEMP_FILTERS}}, $pipe_reader;
        }
        else {
           my $pipe_writer = sub {
              my ( $in_ref, $out_ref ) = @_;
              return undef unless defined $pipe->{FD};
              return 0
                 unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
                    || $pipe->{PAUSED};
  
              vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
  
              if ( ! length $$in_ref ) {
                 if ( ! defined get_more_input ) {
                    $self->_clobber( $pipe );
                    return undef;
                 }
              }
  
              unless ( length $$in_ref ) {
                 unless ( $pipe->{PAUSED} ) {
                    _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
                    vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
  #		  vec( $self->{EIN}, $pipe->{FD}, 1 ) = 0;
                    vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
                    $pipe->{PAUSED} = 1;
                 }
                 return 0;
              }
              _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
  
              my $c = _write( $pipe->{FD}, $$in_ref );
              substr( $$in_ref, 0, $c, '' );
              return 1;
           };
           ## Output filters are the first filters
           unshift @{$pipe->{FILTERS}}, $pipe_writer;
           push    @{$self->{TEMP_FILTERS}}, $pipe_writer;
        }
     }
  }
  
  
  sub _dup2_gently {
     ## A METHOD, NOT A FUNCTION, NEEDS $self!
     my IPC::Run $self = shift;
     my ( $files, $fd1, $fd2 ) = @_;
     ## Moves TFDs that are using the destination fd out of the
     ## way before calling _dup2
     for ( @$files ) {
        next unless defined $_->{TFD};
        $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
     }
     $self->{DEBUG_FD} = _dup $self->{DEBUG_FD}
        if defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2;
  
     _dup2_rudely( $fd1, $fd2 );
  }
  
  =pod
  
  =item close_terminal
  
  This is used as (or in) an init sub to cast off the bonds of a controlling
  terminal.  It must precede all other redirection ops that affect
  STDIN, STDOUT, or STDERR to be guaranteed effective.
  
  =cut
  
  
  sub close_terminal {
     ## Cast of the bonds of a controlling terminal
  
     POSIX::setsid() || croak "POSIX::setsid() failed";
     _debug "closing stdin, out, err"
        if _debugging_details;
     close STDIN;
     close STDERR;
     close STDOUT;
  }
  
  
  sub _do_kid_and_exit {
     my IPC::Run $self = shift;
     my ( $kid ) = @_;
  
     ## For unknown reasons, placing these two statements in the eval{}
     ## causes the eval {} to not catch errors after they are executed in
     ## perl 5.6.0, godforsaken version that it is...not sure about 5.6.1.
     ## Part of this could be that these symbols get destructed when
     ## exiting the eval, and that destruction might be what's (wrongly)
     ## confusing the eval{}, allowing the exception to probpogate.
     my $s1 = gensym;
     my $s2 = gensym;
  
     eval {
        local $cur_self = $self;
  
        _set_child_debug_name( ref $kid->{VAL} eq "CODE"
  	 ? "CODE"
  	 : basename( $kid->{VAL}->[0] )
        );
  
        ## close parent FD's first so they're out of the way.
        ## Don't close STDIN, STDOUT, STDERR: they should be inherited or
        ## overwritten below.
        my @needed = $self->{noinherit} ? () : ( 1, 1, 1 );
        $needed[ $self->{SYNC_WRITER_FD} ] = 1;
        $needed[ $self->{DEBUG_FD} ] = 1 if defined $self->{DEBUG_FD};
  
        for ( @{$kid->{OPS}} ) {
  	 $needed[ $_->{TFD} ] = 1 if defined $_->{TFD};
        }
  
        ## TODO: use the forthcoming IO::Pty to close the terminal and
        ## make the first pty for this child the controlling terminal.
        ## This will also make it so that pty-laden kids don't cause
        ## other kids to lose stdin/stdout/stderr.
        my @closed;
        if ( %{$self->{PTYS}} ) {
  	 ## Clean up the parent's fds.
  	 for ( keys %{$self->{PTYS}} ) {
  	    _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
  	    my $slave = $self->{PTYS}->{$_}->slave;
  	    $closed[ $self->{PTYS}->{$_}->fileno ] = 1;
  	    close $self->{PTYS}->{$_};
  	    $self->{PTYS}->{$_} = $slave;
  	 }
  
  	 close_terminal;
  	 $closed[ $_ ] = 1 for ( 0..2 );
        }
  
        for my $sibling ( @{$self->{KIDS}} ) {
  	 for ( @{$sibling->{OPS}} ) {
  	    if ( $_->{TYPE} =~ /^.pty.$/ ) {
  	       $_->{TFD} = $self->{PTYS}->{$_->{PTY_ID}}->fileno;
  	       $needed[$_->{TFD}] = 1;
  	    }
  
  #	    for ( $_->{FD}, ( $sibling != $kid ? $_->{TFD} : () ) ) {
  #	       if ( defined $_ && ! $closed[$_] && ! $needed[$_] ) {
  #		  _close( $_ );
  #		  $closed[$_] = 1;
  #		  $_ = undef;
  #	       }
  #	    }
  	 }
        }
  
        ## This is crude: we have no way of keeping track of browsing all open
        ## fds, so we scan to a fairly high fd.
        _debug "open fds: ", join " ", keys %fds if _debugging_details;
        for (keys %fds) {
           if ( ! $closed[$_] && ! $needed[$_] ) {
              _close( $_ );
              $closed[$_] = 1;
           }
        }
  
        ## Lazy closing is so the same fd (ie the same TFD value) can be dup2'ed on
        ## several times.
        my @lazy_close;
        for ( @{$kid->{OPS}} ) {
  	 if ( defined $_->{TFD} ) {
  	    unless ( $_->{TFD} == $_->{KFD} ) {
  	       $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
  	       push @lazy_close, $_->{TFD};
  	    }
  	 }
  	 elsif ( $_->{TYPE} eq 'dup' ) {
  	    $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
  	       unless $_->{KFD1} == $_->{KFD2};
  	 }
  	 elsif ( $_->{TYPE} eq 'close' ) {
  	    for ( $_->{KFD} ) {
  	       if ( ! $closed[$_] ) {
  		  _close( $_ );
  		  $closed[$_] = 1;
  		  $_ = undef;
  	       }
  	    }
  	 }
  	 elsif ( $_->{TYPE} eq 'init' ) {
  	    $_->{SUB}->();
  	 }
        }
  
        for ( @lazy_close ) {
  	 unless ( $closed[$_] ) {
  	    _close( $_ );
  	    $closed[$_] = 1;
  	 }
        }
  
        if ( ref $kid->{VAL} ne 'CODE' ) {
  	 open $s1, ">&=$self->{SYNC_WRITER_FD}"
  	    or croak "$! setting filehandle to fd SYNC_WRITER_FD";
  	 fcntl $s1, F_SETFD, 1;
  
  	 if ( defined $self->{DEBUG_FD} ) {
  	    open $s2, ">&=$self->{DEBUG_FD}"
  	       or croak "$! setting filehandle to fd DEBUG_FD";
  	    fcntl $s2, F_SETFD, 1;
  	 }
  
  	 my @cmd = ( $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}] );
  	 _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd
  	    if _debugging;
  
  	 die "exec failed: simulating exec() failure"
  	    if $self->{_simulate_exec_failure};
  
  	 _exec $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}];
  
  	 croak "exec failed: $!";
        }
     };
     if ( $@ ) {
        _write $self->{SYNC_WRITER_FD}, $@;
        ## Avoid DESTROY.
        POSIX::exit 1;
     }
  
     ## We must be executing code in the child, otherwise exec() would have
     ## prevented us from being here.
     _close $self->{SYNC_WRITER_FD};
     _debug 'calling fork()ed CODE ref' if _debugging;
     POSIX::close $self->{DEBUG_FD}      if defined $self->{DEBUG_FD};
     ## TODO: Overload CORE::GLOBAL::exit...
     $kid->{VAL}->();
  
     ## There are bugs in perl closures up to and including 5.6.1
     ## that may keep this next line from having any effect, and it
     ## won't have any effect if our caller has kept a copy of it, but
     ## this may cause the closure to be cleaned up.  Maybe.
     $kid->{VAL} = undef;
  
     ## Use POSIX::exit to avoid global destruction, since this might
     ## cause DESTROY() to be called on objects created in the parent
     ## and thus cause double cleanup.  For instance, if DESTROY() unlinks
     ## a file in the child, we don't want the parent to suddenly miss
     ## it.
     POSIX::exit 0;
  }
  
  =pod
  
  =item start
  
     $h = start(
        \@cmd, \$in, \$out, ...,
        timeout( 30, name => "process timeout" ),
        $stall_timeout = timeout( 10, name => "stall timeout"   ),
     );
  
     $h = start \@cmd, '<', \$in, '|', \@cmd2, ...;
  
  start() accepts a harness or harness specification and returns a harness
  after building all of the pipes and launching (via fork()/exec(), or, maybe
  someday, spawn()) all the child processes.  It does not send or receive any
  data on the pipes, see pump() and finish() for that.
  
  You may call harness() and then pass it's result to start() if you like,
  but you only need to if it helps you structure or tune your application.
  If you do call harness(), you may skip start() and proceed directly to
  pump.
  
  start() also starts all timers in the harness.  See L<IPC::Run::Timer>
  for more information.
  
  start() flushes STDOUT and STDERR to help you avoid duplicate output.
  It has no way of asking Perl to flush all your open filehandles, so
  you are going to need to flush any others you have open.  Sorry.
  
  Here's how if you don't want to alter the state of $| for your
  filehandle:
  
     $ofh = select HANDLE; $of = $|; $| = 1; $| = $of; select $ofh;
  
  If you don't mind leaving output unbuffered on HANDLE, you can do
  the slightly shorter
  
     $ofh = select HANDLE; $| = 1; select $ofh;
  
  Or, you can use IO::Handle's flush() method:
  
     use IO::Handle;
     flush HANDLE;
  
  Perl needs the equivalent of C's fflush( (FILE *)NULL ).
  
  =cut
  
  sub start {
  # $SIG{__DIE__} = sub { my $s = shift; Carp::cluck $s; die $s };
     my $options;
     if ( @_ && ref $_[-1] eq 'HASH' ) {
        $options = pop;
        require Data::Dumper;
        carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper( $options );
     }
  
     my IPC::Run $self;
     if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
        $self = shift;
        $self->{$_} = $options->{$_} for keys %$options;
     }
     else {
        $self = harness( @_, $options ? $options : () );
     }
  
     local $cur_self = $self;
  
     $self->kill_kill if $self->{STATE} == _started;
  
     _debug "** starting" if _debugging;
  
     $_->{RESULT} = undef for @{$self->{KIDS}};
  
     ## Assume we're not being called from &run.  It will correct our
     ## assumption if need be.  This affects whether &_select_loop clears
     ## input queues to '' when they're empty.
     $self->{clear_ins} = 1;
  
     IPC::Run::Win32Helper::optimize $self
         if Win32_MODE && $in_run;
  
     my @errs;
  
     for ( @{$self->{TIMERS}} ) {
        eval { $_->start };
        if ( $@ ) {
           push @errs, $@;
           _debug 'caught ', $@ if _debugging;
        }
     }
  
     eval { $self->_open_pipes };
     if ( $@ ) {
        push @errs, $@;
        _debug 'caught ', $@ if _debugging;
     }
  
     if ( ! @errs ) {
        ## This is a bit of a hack, we should do it for all open filehandles.
        ## Since there's no way I know of to enumerate open filehandles, we
        ## autoflush STDOUT and STDERR.  This is done so that the children don't
        ## inherit output buffers chock full o' redundant data.  It's really
        ## confusing to track that down.
        { my $ofh = select STDOUT; local $| = 1; select $ofh; }
        { my $ofh = select STDERR; local $| = 1; select $ofh; }
        for my $kid ( @{$self->{KIDS}} ) {
           $kid->{RESULT} = undef;
           _debug "child: ",
              ref( $kid->{VAL} ) eq "CODE"
              ? "CODE ref"
              : (
                 "`",
                 join( " ", map /[^\w.-]/ ? "'$_'" : $_, @{$kid->{VAL}} ),
                 "`"
              ) if _debugging_details;
           eval {
              croak "simulated failure of fork"
                 if $self->{_simulate_fork_failure};
              unless ( Win32_MODE ) {
  	       $self->_spawn( $kid );
              }
              else {
  ## TODO: Test and debug spawing code.  Someday.
                 _debug( 
                    'spawning ',
                    join(
                       ' ',
                       map(
                          "'$_'",
                          ( $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}] )
                       )
                    )
                 ) if _debugging;
  	       ## The external kid wouldn't know what to do with it anyway.
  	       ## This is only used by the "helper" pump processes on Win32.
  	       _dont_inherit( $self->{DEBUG_FD} );
                 ( $kid->{PID}, $kid->{PROCESS} ) =
  		  IPC::Run::Win32Helper::win32_spawn( 
  		     [ $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}] ],
  		     $kid->{OPS},
  		  );
                 _debug "spawn() = ", $kid->{PID} if _debugging;
              }
           };
           if ( $@ ) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
           }
        }
     }
  
     ## Close all those temporary filehandles that the kids needed.
     for my $pty ( values %{$self->{PTYS}} ) {
        close $pty->slave;
     }
  
     my @closed;
     for my $kid ( @{$self->{KIDS}} ) {
        for ( @{$kid->{OPS}} ) {
           my $close_it = eval {
              defined $_->{TFD}
                 && ! $_->{DONT_CLOSE}
                 && ! $closed[$_->{TFD}]
                 && ( ! Win32_MODE || ! $_->{RECV_THROUGH_TEMP_FILE} ) ## Win32 hack
           };
           if ( $@ ) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
           }
           if ( $close_it || $@ ) {
              eval {
                 _close( $_->{TFD} );
                 $closed[$_->{TFD}] = 1;
                 $_->{TFD} = undef;
              };
              if ( $@ ) {
                 push @errs, $@;
                 _debug 'caught ', $@ if _debugging;
              }
           }
        }
     }
  confess "gak!" unless defined $self->{PIPES};
  
     if ( @errs ) {
        eval { $self->_cleanup };
        warn $@ if $@;
        die join( '', @errs );
     }
  
     $self->{STATE} = _started;
     return $self;
  }
  
  =item adopt
  
  Experimental feature. NOT FUNCTIONAL YET, NEED TO CLOSE FDS BETTER IN CHILDREN.  SEE t/adopt.t for a test suite.
  
  =cut
  
  sub adopt {
     my IPC::Run $self = shift;
  
     for my $adoptee ( @_ ) {
        push @{$self->{IOS}},    @{$adoptee->{IOS}};
        ## NEED TO RENUMBER THE KIDS!!
        push @{$self->{KIDS}},   @{$adoptee->{KIDS}};
        push @{$self->{PIPES}},  @{$adoptee->{PIPES}};
        $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_}
           for keys %{$adoptee->{PYTS}};
        push @{$self->{TIMERS}}, @{$adoptee->{TIMERS}};
        $adoptee->{STATE} = _finished;
     }
  }
  
  
  sub _clobber {
     my IPC::Run $self = shift;
     my ( $file ) = @_;
     _debug_desc_fd( "closing", $file ) if _debugging_details;
     my $doomed = $file->{FD};
     my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
     vec( $self->{$dir}, $doomed, 1 ) = 0;
  #   vec( $self->{EIN},  $doomed, 1 ) = 0;
     vec( $self->{PIN},  $doomed, 1 ) = 0;
     if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
        if ( $1 eq '>' ) {
           ## Only close output ptys.  This is so that ptys as inputs are
           ## never autoclosed, which would risk losing data that was
           ## in the slave->parent queue.
           _debug_desc_fd "closing pty", $file if _debugging_details;
           close $self->{PTYS}->{$file->{PTY_ID}}
              if defined $self->{PTYS}->{$file->{PTY_ID}};
           $self->{PTYS}->{$file->{PTY_ID}} = undef;
        }
     }
     elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
        $file->close unless $file->{DONT_CLOSE};
     }
     else {
        _close( $doomed );
     }
  
     @{$self->{PIPES}} = grep
        defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed),
        @{$self->{PIPES}};
  
     $file->{FD} = undef;
  }
  
  sub _select_loop {
     my IPC::Run $self = shift;
  
     my $io_occurred;
  
     my $not_forever = 0.01;
  
  SELECT:
     while ( $self->pumpable ) {
        if ( $io_occurred && $self->{break_on_io} ) {
           _debug "exiting _select(): io occured and break_on_io set"
  	    if _debugging_details;
           last;
        }
  
        my $timeout = $self->{non_blocking} ? 0 : undef;
  
        if ( @{$self->{TIMERS}} ) {
           my $now = time;
           my $time_left;
           for ( @{$self->{TIMERS}} ) {
              next unless $_->is_running;
              $time_left = $_->check( $now );
              ## Return when a timer expires
              return if defined $time_left && ! $time_left;
              $timeout = $time_left
                 if ! defined $timeout || $time_left < $timeout;
           }
        }
  
        ##
        ## See if we can unpause any input channels
        ##
        my $paused = 0;
  
        for my $file ( @{$self->{PIPES}} ) {
           next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
  
           _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
           my $did;
           1 while $did = $file->_do_filters( $self );
           if ( defined $file->{FD} && ! defined( $did ) || $did ) {
              _debug_desc_fd( "unpausing", $file ) if _debugging_details;
              $file->{PAUSED} = 0;
              vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
  #	    vec( $self->{EIN}, $file->{FD}, 1 ) = 1;
              vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
           }
           else {
              ## This gets incremented occasionally when the IO channel
              ## was actually closed.  That's a bug, but it seems mostly
              ## harmless: it causes us to exit if break_on_io, or to set
              ## the timeout to not be forever.  I need to fix it, though.
              ++$paused;
           }
        }
  
        if ( _debugging_details ) {
           my $map = join(
              '',
              map {
                 my $out;
                 $out = 'r'                     if vec( $self->{RIN}, $_, 1 );
                 $out = $out ? 'b' : 'w'        if vec( $self->{WIN}, $_, 1 );
                 $out = 'p'           if ! $out && vec( $self->{PIN}, $_, 1 );
                 $out = $out ? uc( $out ) : 'x' if vec( $self->{EIN}, $_, 1 );
                 $out = '-' unless $out;
                 $out;
              } (0..1024)
           );
           $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
           _debug 'fds for select: ', $map if _debugging_details;
        }
  
        ## _do_filters may have closed our last fd, and we need to see if
        ## we have I/O, or are just waiting for children to exit.
        my $p = $self->pumpable;
        last unless $p;
        if ( $p != 0  && ( ! defined $timeout || $timeout > 0.1 ) ) {
           ## No I/O will wake the select loop up, but we have children
           ## lingering, so we need to poll them with a short timeout.
  	 ## Otherwise, assume more input will be coming.
  	 $timeout = $not_forever;
           $not_forever *= 2;
           $not_forever = 0.5 if $not_forever >= 0.5;
        }
  
        ## Make sure we don't block forever in select() because inputs are
        ## paused.
        if ( ! defined $timeout && ! ( @{$self->{PIPES}} - $paused ) ) {
           ## Need to return if we're in pump and all input is paused, or
  	 ## we'll loop until all inputs are unpaused, which is darn near
  	 ## forever.  And a day.
           if ( $self->{break_on_io} ) {
  	    _debug "exiting _select(): no I/O to do and timeout=forever"
                 if _debugging;
  	    last;
  	 }
  
  	 ## Otherwise, assume more input will be coming.
  	 $timeout = $not_forever;
           $not_forever *= 2;
           $not_forever = 0.5 if $not_forever >= 0.5;
        }
  
        _debug 'timeout=', defined $timeout ? $timeout : 'forever'
           if _debugging_details;
  
        my $nfound;
        unless ( Win32_MODE ) {
           $nfound = select(
              $self->{ROUT} = $self->{RIN},
              $self->{WOUT} = $self->{WIN},
              $self->{EOUT} = $self->{EIN},
              $timeout 
  	 );
        }
        else {
  	 my @in = map $self->{$_}, qw( RIN WIN EIN );
  	 ## Win32's select() on Win32 seems to die if passed vectors of
  	 ## all 0's.  Need to report this when I get back online.
  	 for ( @in ) {
  	    $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
  	 }
  
  	 $nfound = select(
              $self->{ROUT} = $in[0],
              $self->{WOUT} = $in[1],
              $self->{EOUT} = $in[2],
              $timeout 
           );
  
  	 for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
  	    $_ = "" unless defined $_;
  	 }
        }
        last if ! $nfound && $self->{non_blocking};
  
        if ($nfound < 0) {
           if ($! == POSIX::EINTR) {
              # Caught a signal before any FD went ready.  Ensure that
              # the bit fields reflect "no FDs ready".
              $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
              $nfound = 0;
           }
           else {
              croak "$! in select";
           }
        }
            ## TODO: Analyze the EINTR failure mode and see if this patch
            ## is adequate and optimal.
            ## TODO: Add an EINTR test to the test suite.
  
        if ( _debugging_details ) {
           my $map = join(
              '',
              map {
                 my $out;
                 $out = 'r'                     if vec( $self->{ROUT}, $_, 1 );
                 $out = $out ? 'b' : 'w'        if vec( $self->{WOUT}, $_, 1 );
                 $out = $out ? uc( $out ) : 'x' if vec( $self->{EOUT}, $_, 1 );
                 $out = '-' unless $out;
                 $out;
              } (0..128)
           );
           $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
           _debug "selected  ", $map;
        }
  
        ## Need to copy since _clobber alters @{$self->{PIPES}}.
        ## TODO: Rethink _clobber().  Rethink $file->{PAUSED}, too.
        my @pipes = @{$self->{PIPES}};
        $io_occurred = $_->poll( $self ) ? 1 : $io_occurred for @pipes;
  #   FILE:
  #      for my $pipe ( @pipes ) {
  #         ## Pipes can be shared among kids.  If another kid closes the
  #         ## pipe, then it's {FD} will be undef.  Also, on Win32, pipes can
  #	 ## be optimized to be files, in which case the FD is left undef
  #	 ## so we don't try to select() on it.
  #         if ( $pipe->{TYPE} =~ /^>/
  #            && defined $pipe->{FD}
  #            && vec( $self->{ROUT}, $pipe->{FD}, 1 )
  #         ) {
  #            _debug_desc_fd( "filtering data from", $pipe ) if _debugging_details;
  #confess "phooey" unless UNIVERSAL::isa( $pipe, "IPC::Run::IO" );
  #            $io_occurred = 1 if $pipe->_do_filters( $self );
  #
  #            next FILE unless defined $pipe->{FD};
  #         }
  #
  #	 ## On Win32, pipes to the child can be optimized to be files
  #	 ## and FD left undefined so we won't select on it.
  #         if ( $pipe->{TYPE} =~ /^</
  #            && defined $pipe->{FD}
  #            && vec( $self->{WOUT}, $pipe->{FD}, 1 )
  #         ) {
  #            _debug_desc_fd( "filtering data to", $pipe ) if _debugging_details;
  #            $io_occurred = 1 if $pipe->_do_filters( $self );
  #
  #            next FILE unless defined $pipe->{FD};
  #         }
  #
  #         if ( defined $pipe->{FD} && vec( $self->{EOUT}, $pipe->{FD}, 1 ) ) {
  #            ## BSD seems to sometimes raise the exceptional condition flag
  #            ## when a pipe is closed before we read it's last data.  This
  #            ## causes spurious warnings and generally renders the exception
  #            ## mechanism useless for our purposes.  The exception
  #            ## flag semantics are too variable (they're device driver
  #            ## specific) for me to easily map to any automatic action like
  #            ## warning or croaking (try running v0.42 if you don't beleive me
  #            ## :-).
  #            warn "Exception on descriptor $pipe->{FD}";
  #         }
  #      }
     }
  
     return;
  }
  
  
  sub _cleanup {
     my IPC::Run $self = shift;
     _debug "cleaning up" if _debugging_details;
  
     for ( values %{$self->{PTYS}} ) {
        next unless ref $_;
        eval {
           _debug "closing slave fd ", fileno $_->slave if _debugging_data;
           close $_->slave;
        };
        carp $@ . " while closing ptys" if $@;
        eval {
           _debug "closing master fd ", fileno $_ if _debugging_data;
           close $_;
        };
        carp $@ . " closing ptys" if $@;
     }
     
     _debug "cleaning up pipes" if _debugging_details;
     ## _clobber modifies PIPES
     $self->_clobber( $self->{PIPES}->[0] ) while @{$self->{PIPES}};
  
     for my $kid ( @{$self->{KIDS}} ) {
        _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
        if ( ! length $kid->{PID} ) {
           _debug 'never ran child ', $kid->{NUM}, ", can't reap"
              if _debugging;
           for my $op ( @{$kid->{OPS}} ) {
              _close( $op->{TFD} )
                 if defined $op->{TFD} && ! defined $op->{TEMP_FILE_HANDLE};
           }
        }
        elsif ( ! defined $kid->{RESULT} ) {
           _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
              if _debugging;
           my $pid = waitpid $kid->{PID}, 0;
           $kid->{RESULT} = $?;
           _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
              if _debugging;
        }
  
  #      if ( defined $kid->{DEBUG_FD} ) {
  #	 die;
  #         @{$kid->{OPS}} = grep
  #            ! defined $_->{KFD} || $_->{KFD} != $kid->{DEBUG_FD},
  #            @{$kid->{OPS}};
  #         $kid->{DEBUG_FD} = undef;
  #      }
  
        _debug "cleaning up filters" if _debugging_details;
        for my $op ( @{$kid->{OPS}} ) {
           @{$op->{FILTERS}} = grep {
              my $filter = $_;
              ! grep $filter == $_, @{$self->{TEMP_FILTERS}};
           } @{$op->{FILTERS}};
        }
  
        for my $op ( @{$kid->{OPS}} ) {
           $op->_cleanup( $self ) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
        }
     }
     $self->{STATE} = _finished;
     @{$self->{TEMP_FILTERS}} = ();
     _debug "done cleaning up" if _debugging_details;
  
     POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
     $self->{DEBUG_FD} = undef;
  }
  
  =pod
  
  =item pump
  
     pump $h;
     $h->pump;
  
  Pump accepts a single parameter harness.  It blocks until it delivers some
  input or recieves some output.  It returns TRUE if there is still input or
  output to be done, FALSE otherwise.
  
  pump() will automatically call start() if need be, so you may call harness()
  then proceed to pump() if that helps you structure your application.
  
  If pump() is called after all harnessed activities have completed, a "process
  ended prematurely" exception to be thrown.  This allows for simple scripting
  of external applications without having to add lots of error handling code at
  each step of the script:
  
     $h = harness \@smbclient, \$in, \$out, $err;
  
     $in = "cd /foo\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /foo:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $h->finish;
  
     warn $err if $err;
  
  =cut
  
  sub pump {
     die "pump() takes only a a single harness as a parameter"
        unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
  
     my IPC::Run $self = shift;
  
     local $cur_self = $self;
  
     _debug "** pumping" 
        if _debugging;
  
  #   my $r = eval {
        $self->start if $self->{STATE} < _started;
        croak "process ended prematurely" unless $self->pumpable;
  
        $self->{auto_close_ins} = 0;
        $self->{break_on_io}    = 1;
        $self->_select_loop;
        return $self->pumpable;
  #   };
  #   if ( $@ ) {
  #      my $x = $@;
  #      _debug $x if _debugging && $x;
  #      eval { $self->_cleanup };
  #      warn $@ if $@;
  #      die $x;
  #   }
  #   return $r;
  }
  
  =pod
  
  =item pump_nb
  
     pump_nb $h;
     $h->pump_nb;
  
  "pump() non-blocking", pumps if anything's ready to be pumped, returns
  immediately otherwise.  This is useful if you're doing some long-running
  task in the foreground, but don't want to starve any child processes.
  
  =cut
  
  sub pump_nb {
     my IPC::Run $self = shift;
  
     $self->{non_blocking} = 1;
     my $r = eval { $self->pump };
     $self->{non_blocking} = 0;
     die $@ if $@;
     return $r;
  }
  
  =pod
  
  =item pumpable
  
  Returns TRUE if calling pump() won't throw an immediate "process ended
  prematurely" exception.  This means that there are open I/O channels or
  active processes. May yield the parent processes' time slice for 0.01
  second if all pipes are to the child and all are paused.  In this case
  we can't tell if the child is dead, so we yield the processor and
  then attempt to reap the child in a nonblocking way.
  
  =cut
  
  ## Undocumented feature (don't depend on it outside this module):
  ## returns -1 if we have I/O channels open, or >0 if no I/O channels
  ## open, but we have kids running.  This allows the select loop
  ## to poll for child exit.
  sub pumpable {
     my IPC::Run $self = shift;
  
     ## There's a catch-22 we can get in to if there is only one pipe left
     ## open to the child and it's paused (ie the SCALAR it's tied to
     ## is '').  It's paused, so we're not select()ing on it, so we don't
     ## check it to see if the child attached to it is alive and it stays
     ## in @{$self->{PIPES}} forever.  So, if all pipes are paused, see if
     ## we can reap the child.
     return -1 if grep !$_->{PAUSED}, @{$self->{PIPES}};
  
     ## See if the child is dead.
     $self->reap_nb;
     return 0 unless $self->_running_kids;
  
     ## If we reap_nb and it's not dead yet, yield to it to see if it
     ## exits.
     ##
     ## A better solution would be to unpause all the pipes, but I tried that
     ## and it never errored on linux.  Sigh.  
     select undef, undef, undef, 0.0001;
  
     ## try again
     $self->reap_nb;
     return 0 unless $self->_running_kids;
  
     return -1; ## There are pipes waiting
  }
  
  
  sub _running_kids {
     my IPC::Run $self = shift;
     return grep
        defined $_->{PID} && ! defined $_->{RESULT},
        @{$self->{KIDS}};
  }
  
  =pod
  
  =item reap_nb
  
  Attempts to reap child processes, but does not block.
  
  Does not currently take any parameters, one day it will allow specific
  children to be reaped.
  
  Only call this from a signal handler if your C<perl> is recent enough
  to have safe signal handling (5.6.1 did not, IIRC, but it was beign discussed
  on perl5-porters).  Calling this (or doing any significant work) in a signal
  handler on older C<perl>s is asking for seg faults.
  
  =cut
  
  my $still_runnings;
  
  sub reap_nb {
     my IPC::Run $self = shift;
  
     local $cur_self = $self;
  
     ## No more pipes, look to see if all the kids yet live, reaping those
     ## that haven't.  I'd use $SIG{CHLD}/$SIG{CLD}, but that's broken
     ## on older (SYSV) platforms and perhaps less portable than waitpid().
     ## This could be slow with a lot of kids, but that's rare and, well,
     ## a lot of kids is slow in the first place.
     ## Oh, and this keeps us from reaping other children the process
     ## may have spawned.
     for my $kid ( @{$self->{KIDS}} ) {
        if ( Win32_MODE ) {
  	 next if ! defined $kid->{PROCESS} || defined $kid->{RESULT};
  	 unless ( $kid->{PROCESS}->Wait( 0 ) ) {
  	    _debug "kid $kid->{NUM} ($kid->{PID}) still running"
                 if _debugging_details;
  	    next;
  	 }
  
           _debug "kid $kid->{NUM} ($kid->{PID}) exited"
              if _debugging;
  
  	 $kid->{PROCESS}->GetExitCode( $kid->{RESULT} )
  	    or croak "$! while GetExitCode()ing for Win32 process";
  
  	 unless ( defined $kid->{RESULT} ) {
  	    $kid->{RESULT} = "0 but true";
  	    $? = $kid->{RESULT} = 0x0F;
  	 }
  	 else {
  	    $? = $kid->{RESULT} << 8;
  	 }
        }
        else {
  	 next if ! defined $kid->{PID} || defined $kid->{RESULT};
  	 my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
  	 unless ( $pid ) {
  	    _debug "$kid->{NUM} ($kid->{PID}) still running"
                 if _debugging_details;
  	    next;
  	 }
  
  	 if ( $pid < 0 ) {
  	    _debug "No such process: $kid->{PID}\n" if _debugging;
  	    $kid->{RESULT} = "unknown result, unknown PID";
  	 }
  	 else {
              _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                 if _debugging;
  
  	    confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
  	       unless $pid = $kid->{PID};
  	    _debug "$kid->{PID} returned $?\n" if _debugging;
  	    $kid->{RESULT} = $?;
  	 }
        }
     }
  }
  
  =pod
  
  =item finish
  
  This must be called after the last start() or pump() call for a harness,
  or your system will accumulate defunct processes and you may "leak"
  file descriptors.
  
  finish() returns TRUE if all children returned 0 (and were not signaled and did
  not coredump, ie ! $?), and FALSE otherwise (this is like run(), and the
  opposite of system()).
  
  Once a harness has been finished, it may be run() or start()ed again,
  including by pump()s auto-start.
  
  If this throws an exception rather than a normal exit, the harness may
  be left in an unstable state, it's best to kill the harness to get rid
  of all the child processes, etc.
  
  Specifically, if a timeout expires in finish(), finish() will not
  kill all the children.  Call C<<$h->kill_kill>> in this case if you care.
  This differs from the behavior of L</run>.
  
  =cut
  
  sub finish {
     my IPC::Run $self = shift;
     my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
  
     local $cur_self = $self;
  
     _debug "** finishing" if _debugging;
  
     $self->{non_blocking}   = 0;
     $self->{auto_close_ins} = 1;
     $self->{break_on_io}    = 0;
     # We don't alter $self->{clear_ins}, start() and run() control it.
  
     while ( $self->pumpable ) {
        $self->_select_loop( $options );
     }
     $self->_cleanup;
  
     return ! $self->full_result;
  }
  
  =pod
  
  =item result
  
     $h->result;
  
  Returns the first non-zero result code (ie $? >> 8).  See L</full_result> to 
  get the $? value for a child process.
  
  To get the result of a particular child, do:
  
     $h->result( 0 );  # first child's $? >> 8
     $h->result( 1 );  # second child
  
  or
  
     ($h->results)[0]
     ($h->results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub _assert_finished {
     my IPC::Run $self = $_[0];
  
     croak "Harness not run" unless $self->{STATE} >= _finished;
     croak "Harness not finished running" unless $self->{STATE} == _finished;
  }
  
  
  sub result {
     &_assert_finished;
     my IPC::Run $self = shift;
     
     if ( @_ ) {
        my ( $which ) = @_;
        croak(
           "Only ",
           scalar( @{$self->{KIDS}} ),
           " child processes, no process $which"
        )
           unless $which >= 0 && $which <= $#{$self->{KIDS}};
        return $self->{KIDS}->[$which]->{RESULT} >> 8;
     }
     else {
        return undef unless @{$self->{KIDS}};
        for ( @{$self->{KIDS}} ) {
           return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
        }
     }
  }
  
  =pod
  
  =item results
  
  Returns a list of child exit values.  See L</full_results> if you want to
  know if a signal killed the child.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub results {
     &_assert_finished;
     my IPC::Run $self = shift;
  
     # we add 0 here to stop warnings associated with "unknown result, unknown PID"
     return map { (0+$_->{RESULT}) >> 8 } @{$self->{KIDS}};
  }
  
  =pod
  
  =item full_result
  
     $h->full_result;
  
  Returns the first non-zero $?.  See L</result> to get the first $? >> 8 
  value for a child process.
  
  To get the result of a particular child, do:
  
     $h->full_result( 0 );  # first child's $? >> 8
     $h->full_result( 1 );  # second child
  
  or
  
     ($h->full_results)[0]
     ($h->full_results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub full_result {
     goto &result if @_ > 1;
     &_assert_finished;
  
     my IPC::Run $self = shift;
  
     return undef unless @{$self->{KIDS}};
     for ( @{$self->{KIDS}} ) {
        return $_->{RESULT} if $_->{RESULT};
     }
  }
  
  =pod
  
  =item full_results
  
  Returns a list of child exit values as returned by C<wait>.  See L</results>
  if you don't care about coredumps or signals.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub full_results {
     &_assert_finished;
     my IPC::Run $self = shift;
  
     croak "Harness not run" unless $self->{STATE} >= _finished;
     croak "Harness not finished running" unless $self->{STATE} == _finished;
  
     return map $_->{RESULT}, @{$self->{KIDS}};
  }
  
  
  ##
  ## Filter Scaffolding
  ##
  use vars (
     '$filter_op',        ## The op running a filter chain right now
     '$filter_num',       ## Which filter is being run right now.
  );
  
  ##
  ## A few filters and filter constructors
  ##
  
  =pod
  
  =back
  
  =back
  
  =head1 FILTERS
  
  These filters are used to modify input our output between a child
  process and a scalar or subroutine endpoint.
  
  =over
  
  =item binary
  
     run \@cmd, ">", binary, \$out;
     run \@cmd, ">", binary, \$out;  ## Any TRUE value to enable
     run \@cmd, ">", binary 0, \$out;  ## Any FALSE value to disable
  
  This is a constructor for a "binmode" "filter" that tells IPC::Run to keep
  the carriage returns that would ordinarily be edited out for you (binmode
  is usually off).  This is not a real filter, but an option masquerading as
  a filter.
  
  It's not named "binmode" because you're likely to want to call Perl's binmode
  in programs that are piping binary data around.
  
  =cut
  
  sub binary(;$) {
     my $enable = @_ ? shift : 1;
     return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
  }
  
  =pod
  
  =item new_chunker
  
  This breaks a stream of data in to chunks, based on an optional
  scalar or regular expression parameter.  The default is the Perl
  input record separator in $/, which is a newline be default.
  
     run \@cmd, '>', new_chunker, \&lines_handler;
     run \@cmd, '>', new_chunker( "\r\n" ), \&lines_handler;
  
  Because this uses $/ by default, you should always pass in a parameter
  if you are worried about other code (modules, etc) modifying $/.
  
  If this filter is last in a filter chain that dumps in to a scalar,
  the scalar must be set to '' before a new chunk will be written to it.
  
  As an example of how a filter like this can be written, here's a
  chunker that splits on newlines:
  
     sub line_splitter {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/\A(.*?\n)// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  
  =cut
  
  sub new_chunker(;$) {
     my ( $re ) = @_;
     $re = $/ if _empty $re;
     $re = quotemeta( $re ) unless ref $re eq 'Regexp';
     $re = qr/\A(.*?$re)/s;
  
     return sub {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/$re// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  }
  
  =pod
  
  =item new_appender
  
  This appends a fixed string to each chunk of data read from the source
  scalar or sub.  This might be useful if you're writing commands to a
  child process that always must end in a fixed string, like "\n":
  
     run( \@cmd,
        '<', new_appender( "\n" ), \&commands,
     );
  
  Here's a typical filter sub that might be created by new_appender():
  
     sub newline_appender {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, "\n" );
           $$in_ref = '';
           1;
        }
     };
  
  =cut
  
  sub new_appender($) {
     my ( $suffix ) = @_;
     croak "\$suffix undefined" unless defined $suffix;
  
     return sub {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
           $$in_ref = '';
           1;
        }
     };
  }
  
  =item new_string_source
  
  TODO: Needs confirmation. Was previously undocumented. in this module.
  
  This is a filter which is exportable. Returns a sub which appends the data passed in to the output buffer and returns 1 if data was appended. 0 if it was an empty string and undef if no data was passed. 
  
  NOTE: Any additional variables passed to new_string_source will be passed to the sub every time it's called and appended to the output. 
  
  =cut
  
  
  sub new_string_source {
     my $ref;
     if ( @_ > 1 ) {
        $ref = [ @_ ],
     }
     else {
        $ref = shift;
     }
  
     return ref $ref eq 'SCALAR'
        ? sub {
           my ( $in_ref, $out_ref ) = @_;
  
           return defined $$ref
              ? do {
                 $$out_ref .= $$ref;
                 my $r = length $$ref ? 1 : 0;
                 $$ref = undef;
                 $r;
              }
              : undef
        }
        : sub {
           my ( $in_ref, $out_ref ) = @_;
  
           return @$ref
              ? do {
                 my $s = shift @$ref;
                 $$out_ref .= $s;
                 length $s ? 1 : 0;
              }
              : undef;
        }
  }
  
  =item new_string_sink
  
  TODO: Needs confirmation. Was previously undocumented.
  
  This is a filter which is exportable. Returns a sub which pops the data out of the input stream and pushes it onto the string.
  
  =cut
  
  sub new_string_sink {
     my ( $string_ref ) = @_;
  
     return sub {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$string_ref .= $$in_ref;
           $$in_ref = '';
           1;
        }
     };
  }
  
  
  #=item timeout
  #
  #This function defines a time interval, starting from when start() is
  #called, or when timeout() is called.  If all processes have not finished
  #by the end of the timeout period, then a "process timed out" exception
  #is thrown.
  #
  #The time interval may be passed in seconds, or as an end time in
  #"HH:MM:SS" format (any non-digit other than '.' may be used as
  #spacing and puctuation).  This is probably best shown by example:
  #
  #   $h->timeout( $val );
  #
  #   $val                     Effect
  #   ======================== =====================================
  #   undef                    Timeout timer disabled
  #   ''                       Almost immediate timeout
  #   0                        Almost immediate timeout
  #   0.000001                 timeout > 0.0000001 seconds
  #   30                       timeout > 30 seconds
  #   30.0000001               timeout > 30 seconds
  #   10:30                    timeout > 10 minutes, 30 seconds
  #
  #Timeouts are currently evaluated with a 1 second resolution, though
  #this may change in the future.  This means that setting
  #timeout($h,1) will cause a pokey child to be aborted sometime after
  #one second has elapsed and typically before two seconds have elapsed.
  #
  #This sub does not check whether or not the timeout has expired already.
  #
  #Returns the number of seconds set as the timeout (this does not change
  #as time passes, unless you call timeout( val ) again).
  #
  #The timeout does not include the time needed to fork() or spawn()
  #the child processes, though some setup time for the child processes can
  #included.  It also does not include the length of time it takes for
  #the children to exit after they've closed all their pipes to the
  #parent process.
  #
  #=cut
  #
  #sub timeout {
  #   my IPC::Run $self = shift;
  #
  #   if ( @_ ) {
  #      ( $self->{TIMEOUT} ) = @_;
  #      $self->{TIMEOUT_END} = undef;
  #      if ( defined $self->{TIMEOUT} ) {
  #	 if ( $self->{TIMEOUT} =~ /[^\d.]/ ) {
  #	    my @f = split( /[^\d\.]+/i, $self->{TIMEOUT} );
  #	    unshift @f, 0 while @f < 3;
  #	    $self->{TIMEOUT} = (($f[0]*60)+$f[1])*60+$f[2];
  #	 }
  #	 elsif ( $self->{TIMEOUT} =~ /^(\d*)(?:\.(\d*))/ ) {
  #	    $self->{TIMEOUT} = $1 + 1;
  #	 }
  #	 $self->_calc_timeout_end if $self->{STATE} >= _started;
  #      }
  #   }
  #   return $self->{TIMEOUT};
  #}
  #
  #
  #sub _calc_timeout_end {
  #   my IPC::Run $self = shift;
  #
  #   $self->{TIMEOUT_END} = defined $self->{TIMEOUT} 
  #      ? time + $self->{TIMEOUT}
  #      : undef;
  #
  #   ## We add a second because we might be at the very end of the current
  #   ## second, and we want to guarantee that we don't have a timeout even
  #   ## one second less then the timeout period.
  #   ++$self->{TIMEOUT_END} if $self->{TIMEOUT};
  #}
  
  =pod
  
  =item io
  
  Takes a filename or filehandle, a redirection operator, optional filters,
  and a source or destination (depends on the redirection operator).  Returns
  an IPC::Run::IO object suitable for harness()ing (including via start()
  or run()).
  
  This is shorthand for 
  
  
     require IPC::Run::IO;
  
        ... IPC::Run::IO->new(...) ...
  
  =cut
  
  sub io {
     require IPC::Run::IO;
     IPC::Run::IO->new( @_ );
  }
  
  =pod
  
  =item timer
  
     $h = start( \@cmd, \$in, \$out, $t = timer( 5 ) );
  
     pump $h until $out =~ /expected stuff/ || $t->is_expired;
  
  Instantiates a non-fatal timer.  pump() returns once each time a timer
  expires.  Has no direct effect on run(), but you can pass a subroutine
  to fire when the timer expires. 
  
  See L</timeout> for building timers that throw exceptions on
  expiration.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timer;
  *timer = \&IPC::Run::Timer::timer;
  
  =pod
  
  =item timeout
  
     $h = start( \@cmd, \$in, \$out, $t = timeout( 5 ) );
  
     pump $h until $out =~ /expected stuff/;
  
  Instantiates a timer that throws an exception when it expires.
  If you don't provide an exception, a default exception that matches
  /^IPC::Run: .*timed out/ is thrown by default.  You can pass in your own
  exception scalar or reference:
  
     $h = start(
        \@cmd, \$in, \$out,
        $t = timeout( 5, exception => 'slowpoke' ),
     );
  
  or set the name used in debugging message and in the default exception
  string:
  
     $h = start(
        \@cmd, \$in, \$out,
        timeout( 50, name => 'process timer' ),
        $stall_timer = timeout( 5, name => 'stall timer' ),
     );
  
     pump $h until $out =~ /started/;
  
     $in = 'command 1';
     $stall_timer->start;
     pump $h until $out =~ /command 1 finished/;
  
     $in = 'command 2';
     $stall_timer->start;
     pump $h until $out =~ /command 2 finished/;
  
     $in = 'very slow command 3';
     $stall_timer->start( 10 );
     pump $h until $out =~ /command 3 finished/;
  
     $stall_timer->start( 5 );
     $in = 'command 4';
     pump $h until $out =~ /command 4 finished/;
  
     $stall_timer->reset; # Prevent restarting or expirng
     finish $h;
  
  See L</timer> for building non-fatal timers.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timeout;
  *timeout = \&IPC::Run::Timer::timeout;
  
  =pod
  
  =back
  
  =head1 FILTER IMPLEMENTATION FUNCTIONS
  
  These functions are for use from within filters.
  
  =over
  
  =item input_avail
  
  Returns TRUE if input is available.  If none is available, then 
  &get_more_input is called and its result is returned.
  
  This is usually used in preference to &get_more_input so that the
  calling filter removes all data from the $in_ref before more data
  gets read in to $in_ref.
  
  C<input_avail> is usually used as part of a return expression:
  
     return input_avail && do {
        ## process the input just gotten
        1;
     };
  
  This technique allows input_avail to return the undef or 0 that a
  filter normally returns when there's no input to process.  If a filter
  stores intermediate values, however, it will need to react to an
  undef:
  
     my $got = input_avail;
     if ( ! defined $got ) {
        ## No more input ever, flush internal buffers to $out_ref
     }
     return $got unless $got;
     ## Got some input, move as much as need be
     return 1 if $added_to_out_ref;
  
  =cut
  
  sub input_avail() {
     confess "Undefined FBUF ref for $filter_num+1"
        unless defined $filter_op->{FBUFS}->[$filter_num+1];
     length ${$filter_op->{FBUFS}->[$filter_num+1]} || get_more_input;
  }
  
  =pod
  
  =item get_more_input
  
  This is used to fetch more input in to the input variable.  It returns
  undef if there will never be any more input, 0 if there is none now,
  but there might be in the future, and TRUE if more input was gotten.
  
  C<get_more_input> is usually used as part of a return expression,
  see L</input_avail> for more information.
  
  =cut
  
  ##
  ## Filter implementation interface
  ##
  sub get_more_input() {
     ++$filter_num;
     my $r = eval {
        confess "get_more_input() called and no more filters in chain"
           unless defined $filter_op->{FILTERS}->[$filter_num];
        $filter_op->{FILTERS}->[$filter_num]->(
           $filter_op->{FBUFS}->[$filter_num+1],
           $filter_op->{FBUFS}->[$filter_num],
        ); # if defined ${$filter_op->{FBUFS}->[$filter_num+1]};
     };
     --$filter_num;
     die $@ if $@;
     return $r;
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 TODO
  
  These will be addressed as needed and as time allows.
  
  Stall timeout.
  
  Expose a list of child process objects.  When I do this,
  each child process is likely to be blessed into IPC::Run::Proc.
  
  $kid->abort(), $kid->kill(), $kid->signal( $num_or_name ).
  
  Write tests for /(full_)?results?/ subs.
  
  Currently, pump() and run() only work on systems where select() works on the
  filehandles returned by pipe().  This does *not* include ActiveState on Win32,
  although it does work on cygwin under Win32 (thought the tests whine a bit).
  I'd like to rectify that, suggestions and patches welcome.
  
  Likewise start() only fully works on fork()/exec() machines (well, just
  fork() if you only ever pass perl subs as subprocesses).  There's
  some scaffolding for calling Open3::spawn_with_handles(), but that's
  untested, and not that useful with limited select().
  
  Support for C<\@sub_cmd> as an argument to a command which
  gets replaced with /dev/fd or the name of a temporary file containing foo's
  output.  This is like <(sub_cmd ...) found in bash and csh (IIRC).
  
  Allow multiple harnesses to be combined as independent sets of processes
  in to one 'meta-harness'.
  
  Allow a harness to be passed in place of an \@cmd.  This would allow
  multiple harnesses to be aggregated.
  
  Ability to add external file descriptors w/ filter chains and endpoints.
  
  Ability to add timeouts and timing generators (i.e. repeating timeouts).
  
  High resolution timeouts.
  
  =head1 Win32 LIMITATIONS
  
  =over
  
  =item Fails on Win9X
  
  If you want Win9X support, you'll have to debug it or fund me because I
  don't use that system any more.  The Win32 subsysem has been extended to
  use temporary files in simple run() invocations and these may actually
  work on Win9X too, but I don't have time to work on it.
  
  =item May deadlock on Win2K (but not WinNT4 or WinXPPro)
  
  Spawning more than one subprocess on Win2K causes a deadlock I haven't
  figured out yet, but simple uses of run() often work.  Passes all tests
  on WinXPPro and WinNT.
  
  =item no support yet for <pty< and >pty>
  
  These are likely to be implemented as "<" and ">" with binmode on, not
  sure.
  
  =item no support for file descriptors higher than 2 (stderr)
  
  Win32 only allows passing explicit fds 0, 1, and 2.  If you really, really need to pass file handles, us Win32API:: GetOsFHandle() or ::FdGetOsFHandle() to
  get the integer handle and pass it to the child process using the command
  line, environment, stdin, intermediary file, or other IPC mechnism.  Then
  use that handle in the child (Win32API.pm provides ways to reconstitute
  Perl file handles from Win32 file handles).
  
  =item no support for subroutine subprocesses (CODE refs)
  
  Can't fork(), so the subroutines would have no context, and closures certainly
  have no meaning
  
  Perhaps with Win32 fork() emulation, this can be supported in a limited
  fashion, but there are other very serious problems with that: all parent
  fds get dup()ed in to the thread emulating the forked process, and that
  keeps the parent from being able to close all of the appropriate fds.
  
  =item no support for init => sub {} routines.
  
  Win32 processes are created from scratch, there is no way to do an init
  routine that will affect the running child.  Some limited support might
  be implemented one day, do chdir() and %ENV changes can be made.
  
  =item signals
  
  Win32 does not fully support signals.  signal() is likely to cause errors
  unless sending a signal that Perl emulates, and C<kill_kill()> is immediately
  fatal (there is no grace period).
  
  =item helper processes
  
  IPC::Run uses helper processes, one per redirected file, to adapt between the
  anonymous pipe connected to the child and the TCP socket connected to the
  parent.  This is a waste of resources and will change in the future to either
  use threads (instead of helper processes) or a WaitForMultipleObjects call
  (instead of select).  Please contact me if you can help with the
  WaitForMultipleObjects() approach; I haven't figured out how to get at it
  without C code.
  
  =item shutdown pause
  
  There seems to be a pause of up to 1 second between when a child program exits
  and the corresponding sockets indicate that they are closed in the parent.
  Not sure why.
  
  =item binmode
  
  binmode is not supported yet.  The underpinnings are implemented, just ask
  if you need it.
  
  =item IPC::Run::IO
  
  IPC::Run::IO objects can be used on Unix to read or write arbitrary files.  On
  Win32, they will need to use the same helper processes to adapt from
  non-select()able filehandles to select()able ones (or perhaps
  WaitForMultipleObjects() will work with them, not sure).
  
  =item startup race conditions
  
  There seems to be an occasional race condition between child process startup
  and pipe closings.  It seems like if the child is not fully created by the time
  CreateProcess returns and we close the TCP socket being handed to it, the
  parent socket can also get closed.  This is seen with the Win32 pumper
  applications, not the "real" child process being spawned.
  
  I assume this is because the kernel hasn't gotten around to incrementing the
  reference count on the child's end (since the child was slow in starting), so
  the parent's closing of the child end causes the socket to be closed, thus
  closing the parent socket.
  
  Being a race condition, it's hard to reproduce, but I encountered it while
  testing this code on a drive share to a samba box.  In this case, it takes
  t/run.t a long time to spawn it's chile processes (the parent hangs in the
  first select for several seconds until the child emits any debugging output).
  
  I have not seen it on local drives, and can't reproduce it at will,
  unfortunately.  The symptom is a "bad file descriptor in select()" error, and,
  by turning on debugging, it's possible to see that select() is being called on
  a no longer open file descriptor that was returned from the _socket() routine
  in Win32Helper.  There's a new confess() that checks for this ("PARENT_HANDLE
  no longer open"), but I haven't been able to reproduce it (typically).
  
  =back
  
  =head1 LIMITATIONS
  
  On Unix, requires a system that supports C<waitpid( $pid, WNOHANG )> so
  it can tell if a child process is still running.
  
  PTYs don't seem to be non-blocking on some versions of Solaris. Here's a
  test script contributed by Borislav Deianov <borislav@ensim.com> to see
  if you have the problem.  If it dies, you have the problem.
  
     #!/usr/bin/perl
  
     use IPC::Run qw(run);
     use Fcntl;
     use IO::Pty;
  
     sub makecmd {
         return ['perl', '-e', 
                 '<STDIN>, print "\n" x '.$_[0].'; while(<STDIN>){last if /end/}'];
     }
  
     #pipe R, W;
     #fcntl(W, F_SETFL, O_NONBLOCK);
     #while (syswrite(W, "\n", 1)) { $pipebuf++ };
     #print "pipe buffer size is $pipebuf\n";
     my $pipebuf=4096;
     my $in = "\n" x ($pipebuf * 2) . "end\n";
     my $out;
  
     $SIG{ALRM} = sub { die "Never completed!\n" };
  
     print "reading from scalar via pipe...";
     alarm( 2 );
     run(makecmd($pipebuf * 2), '<', \$in, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     print "reading from code via pipe... ";
     alarm( 2 );
     run(makecmd($pipebuf * 3), '<', sub { $t = $in; undef $in; $t}, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     $pty = IO::Pty->new();
     $pty->blocking(0);
     $slave = $pty->slave();
     while ($pty->syswrite("\n", 1)) { $ptybuf++ };
     print "pty buffer size is $ptybuf\n";
     $in = "\n" x ($ptybuf * 3) . "end\n";
  
     print "reading via pty... ";
     alarm( 2 );
     run(makecmd($ptybuf * 3), '<pty<', \$in, '>', \$out);
     alarm(0);
     print "done\n";
  
  No support for ';', '&&', '||', '{ ... }', etc: use perl's, since run()
  returns TRUE when the command exits with a 0 result code.
  
  Does not provide shell-like string interpolation.
  
  No support for C<cd>, C<setenv>, or C<export>: do these in an init() sub
  
     run(
        \cmd,
           ...
           init => sub {
              chdir $dir or die $!;
              $ENV{FOO}='BAR'
           }
     );
  
  Timeout calculation does not allow absolute times, or specification of
  days, months, etc.
  
  B<WARNING:> Function coprocesses (C<run \&foo, ...>) suffer from two
  limitations.  The first is that it is difficult to close all filehandles the
  child inherits from the parent, since there is no way to scan all open
  FILEHANDLEs in Perl and it both painful and a bit dangerous to close all open
  file descriptors with C<POSIX::close()>. Painful because we can't tell which
  fds are open at the POSIX level, either, so we'd have to scan all possible fds
  and close any that we don't want open (normally C<exec()> closes any
  non-inheritable but we don't C<exec()> for &sub processes.
  
  The second problem is that Perl's DESTROY subs and other on-exit cleanup gets
  run in the child process.  If objects are instantiated in the parent before the
  child is forked, the the DESTROY will get run once in the parent and once in
  the child.  When coprocess subs exit, POSIX::exit is called to work around this,
  but it means that objects that are still referred to at that time are not
  cleaned up.  So setting package vars or closure vars to point to objects that
  rely on DESTROY to affect things outside the process (files, etc), will
  lead to bugs.
  
  I goofed on the syntax: "<pipe" vs. "<pty<" and ">filename" are both
  oddities.
  
  =head1 TODO
  
  =over
  
  =item Allow one harness to "adopt" another:
  
     $new_h = harness \@cmd2;
     $h->adopt( $new_h );
  
  =item Close all filehandles not explicitly marked to stay open.
  
  The problem with this one is that there's no good way to scan all open
  FILEHANDLEs in Perl, yet you don't want child processes inheriting handles
  willy-nilly.
  
  =back
  
  =head1 INSPIRATION
  
  Well, select() and waitpid() badly needed wrapping, and open3() isn't
  open-minded enough for me.
  
  The shell-like API inspired by a message Russ Allbery sent to perl5-porters,
  which included:
  
     I've thought for some time that it would be
     nice to have a module that could handle full Bourne shell pipe syntax
     internally, with fork and exec, without ever invoking a shell.  Something
     that you could give things like:
  
     pipeopen (PIPE, [ qw/cat file/ ], '|', [ 'analyze', @args ], '>&3');
  
  Message ylln51p2b6.fsf@windlord.stanford.edu, on 2000/02/04.
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=IPC-Run>
  
  For other issues, contact the maintainer (the first listed author)
  
  =head1 AUTHORS
  
  Adam Kennedy <adamk@cpan.org>
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2008 - 2009 Adam Kennedy.
  
  Copyright 1999 Barrie Slaymaker.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the README file.
  
  =cut
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = <<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Debug - debugging routines for IPC::Run
  
  =head1 SYNOPSIS
  
     ##
     ## Environment variable usage
     ##
     ## To force debugging off and shave a bit of CPU and memory
     ## by compile-time optimizing away all debugging code in IPC::Run
     ## (debug => ...) options to IPC::Run will be ignored.
     export IPCRUNDEBUG=none
  
     ## To force debugging on (levels are from 0..10)
     export IPCRUNDEBUG=basic
  
     ## Leave unset or set to "" to compile in debugging support and
     ## allow runtime control of it using the debug option.
  
  =head1 DESCRIPTION
  
  Controls IPC::Run debugging.  Debugging levels are now set by using words,
  but the numbers shown are still supported for backwards compatibility:
  
     0  none         disabled (special, see below)
     1  basic        what's running
     2  data         what's being sent/recieved
     3  details      what's going on in more detail
     4  gory         way too much detail for most uses
     10 all          use this when submitting bug reports
        noopts       optimizations forbidden due to inherited STDIN
  
  The C<none> level is special when the environment variable IPCRUNDEBUG
  is set to this the first time IPC::Run::Debug is loaded: it prevents
  the debugging code from being compiled in to the remaining IPC::Run modules,
  saving a bit of cpu.
  
  To do this in a script, here's a way that allows it to be overridden:
  
     BEGIN {
        unless ( defined $ENV{IPCRUNDEBUG} ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	    or die $@;
        }
     }
  
  This should force IPC::Run to not be debuggable unless somebody sets
  the IPCRUNDEBUG flag; modify this formula to grep @ARGV if need be:
  
     BEGIN {
        unless ( grep /^--debug/, @ARGV ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	 or die $@;
     }
  
  Both of those are untested.
  
  =cut
  
  ## We use @EXPORT for the end user's convenience: there's only one function
  ## exported, it's homonymous with the module, it's an unusual name, and
  ## it can be suppressed by "use IPC::Run ();".
  
  use strict;
  use Exporter;
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
  BEGIN {
  	$VERSION = '0.90';
  	@ISA     = qw( Exporter );
  	@EXPORT  = qw(
  		_debug
  		_debug_desc_fd
  		_debugging
  		_debugging_data
  		_debugging_details
  		_debugging_gory_details
  		_debugging_not_optimized
  		_set_child_debug_name
  	);
  	
  	@EXPORT_OK = qw(
  		_debug_init
  		_debugging_level
  		_map_fds
  	);
  	%EXPORT_TAGS = (
  		default => \@EXPORT,
  		all     => [ @EXPORT, @EXPORT_OK ],
  	);
  }
  
  my $disable_debugging =
     defined $ENV{IPCRUNDEBUG}
     && (
        ! $ENV{IPCRUNDEBUG}
        || lc $ENV{IPCRUNDEBUG} eq "none"
     );
  
  eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX;
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $in_use;
     my $dummy;
     for my $fd (0..63) {
        ## I'd like a quicker way (less user, cpu & expecially sys and kernal
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        ## but that segfaults on Win32
        my $test_fd = POSIX::dup( $fd );
        $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        $map .= $in_use ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to it's own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self ? "#$IPC::Run::cur_self->{ID}" : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
  
  =pod
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>, with numerous suggestions by p5p.
  
  =cut
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = <<'IPC_RUN_IO';
  package IPC::Run::IO;
  
  =head1 NAME
  
  IPC::Run::IO -- I/O channels for IPC::Run.
  
  =head1 SYNOPSIS
  
  B<NOT IMPLEMENTED YET ON Win32! Win32 does not allow select() on
  normal file descriptors; IPC::RUN::IO needs to use IPC::Run::Win32Helper
  to do this.>
  
     use IPC::Run qw( io );
  
     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv );
     $io = io( "filename", 'r',  \$recv );
  
     ## Append to $recv:
     $io = io( "filename", '>>', \$recv );
     $io = io( "filename", 'ra', \$recv );
  
     $io = io( "filename", '<',  \$send );
     $io = io( "filename", 'w',  \$send );
  
     $io = io( "filename", '<<', \$send );
     $io = io( "filename", 'wa', \$send );
  
     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send );
  
     $f = IO::Handle->new( ... ); # Any subclass of IO::Handle
     $io = io( $f, '<', \$send );
  
     require IPC::Run::IO;
     $io = IPC::Run::IO->new( ... );
  
     ## Then run(), harness(), or start():
     run $io, ...;
  
     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... );
  
  =head1 DESCRIPTION
  
  This class and module allows filehandles and filenames to be harnessed for
  I/O when used IPC::Run, independent of anything else IPC::Run is doing
  (except that errors & exceptions can affect all things that IPC::Run is
  doing).
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: due to the awkwardness introduced in ripping pseudohashes
  out of Perl, this class I<no longer> uses the fields pragma.
  
  =cut
  
  ## This class is also used internally by IPC::Run in a very initimate way,
  ## since this is a partial factoring of code from IPC::Run plus some code
  ## needed to do standalone channels.  This factoring process will continue
  ## at some point.  Don't know how far how fast.
  
  use strict;
  use Carp;
  use Fcntl;
  use Symbol;
  
  use IPC::Run::Debug;
  use IPC::Run qw( Win32_MODE );
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '0.90';
  	if ( Win32_MODE ) {
  		eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
  		or ( $@ && die ) or die "$!";
  	}
  }
  
  sub _empty($);
  *_empty = \&IPC::Run::_empty;
  
  =head1 SUBROUTINES
  
  =over 4
  
  =item new
  
  I think it takes >> or << along with some other data.
  
  TODO: Needs more thorough documentation. Patches welcome.
  
  =cut
  
  sub new {
     my $class = shift;
     $class = ref $class || $class;
  
     my ( $external, $type, $internal ) = ( shift, shift, pop );
  
     croak "$class: '$_' is not a valid I/O operator"
        unless $type =~ /^(?:<<?|>>?)$/;
  
     my IPC::Run::IO $self = $class->_new_internal(
        $type, undef, undef, $internal, undef, @_
     );
  
     if ( ! ref $external ) {
        $self->{FILENAME} = $external;
     }
     elsif ( ref eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
        $self->{HANDLE} = $external;
        $self->{DONT_CLOSE} = 1;
     }
     else {
        croak "$class: cannot accept " . ref( $external ) . " to do I/O with";
     }
  
     return $self;
  }
  
  
  ## IPC::Run uses this ctor, since it preparses things and needs more
  ## smarts.
  sub _new_internal {
     my $class = shift;
     $class = ref $class || $class;
  
     $class = "IPC::Run::Win32IO"
        if Win32_MODE && $class eq "IPC::Run::IO";
  
     my IPC::Run::IO $self;
     $self = bless {}, $class;
  
     my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
  
     # Older perls (<=5.00503, at least) don't do list assign to
     # psuedo-hashes well.
     $self->{TYPE}    = $type;
     $self->{KFD}     = $kfd;
     $self->{PTY_ID}  = $pty_id;
     $self->binmode( $binmode );
     $self->{FILTERS} = [ @filters ];
  
     ## Add an adapter to the end of the filter chain (which is usually just the
     ## read/writer sub pushed by IPC::Run) to the DEST or SOURCE, if need be.
     if ( $self->op =~ />/ ) {
        croak "'$_' missing a destination" if _empty $internal;
        $self->{DEST} = $internal;
        if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
           ## Put a filter on the end of the filter chain to pass the
           ## output on to the CODE ref.  For SCALAR refs, the last
           ## filter in the chain writes directly to the scalar itself.  See
           ## _init_filters().  For CODE refs, however, we need to adapt from
           ## the SCALAR to calling the CODE.
           unshift( 
              @{$self->{FILTERS}},
              sub {
                 my ( $in_ref ) = @_;
  
                 return IPC::Run::input_avail() && do {
          	  $self->{DEST}->( $$in_ref );
          	  $$in_ref = '';
          	  1;
                 }
              }
           );
        }
     }
     else {
        croak "'$_' missing a source" if _empty $internal;
        $self->{SOURCE} = $internal;
        if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
           push(
              @{$self->{FILTERS}},
              sub {
                 my ( $in_ref, $out_ref ) = @_;
                 return 0 if length $$out_ref;
  
                 return undef
          	  if $self->{SOURCE_EMPTY};
  
                 my $in = $internal->();
                 unless ( defined $in ) {
          	  $self->{SOURCE_EMPTY} = 1;
          	  return undef 
                 }
                 return 0 unless length $in;
                 $$out_ref = $in;
  
                 return 1;
              }
           );
        }
        elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
           push(
              @{$self->{FILTERS}},
              sub {
                 my ( $in_ref, $out_ref ) = @_;
                 return 0 if length $$out_ref;
  
                 ## pump() clears auto_close_ins, finish() sets it.
                 return $self->{HARNESS}->{auto_close_ins} ? undef : 0
          	  if IPC::Run::_empty ${$self->{SOURCE}}
          	     || $self->{SOURCE_EMPTY};
  
                 $$out_ref = $$internal;
                 eval { $$internal = '' }
          	  if $self->{HARNESS}->{clear_ins};
  
                 $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
  
                 return 1;
              }
           );
        }
     }
  
     return $self;
  }
  
  =item filename
  
  Gets/sets the filename.  Returns the value after the name change, if
  any.
  
  =cut
  
  sub filename {
     my IPC::Run::IO $self = shift;
     $self->{FILENAME} = shift if @_;
     return $self->{FILENAME};
  }
  
  =item init
  
  Does initialization required before this can be run.  This includes open()ing
  the file, if necessary, and clearing the destination scalar if necessary.
  
  =cut
  
  sub init {
     my IPC::Run::IO $self = shift;
  
     $self->{SOURCE_EMPTY} = 0;
     ${$self->{DEST}} = ''
        if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
  
     $self->open if defined $self->filename;
     $self->{FD} = $self->fileno;
  
     if ( ! $self->{FILTERS} ) {
        $self->{FBUFS} = undef;
     }
     else {
        @{$self->{FBUFS}} = map {
           my $s = "";
           \$s;
        } ( @{$self->{FILTERS}}, '' );
  
        $self->{FBUFS}->[0] = $self->{DEST}
           if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
        push @{$self->{FBUFS}}, $self->{SOURCE};
     }
  
     return undef;
  }
  
  
  =item open
  
  If a filename was passed in, opens it.  Determines if the handle is open
  via fileno().  Throws an exception on error.
  
  =cut
  
  my %open_flags = (
     '>'  => O_RDONLY,
     '>>' => O_RDONLY,
     '<'  => O_WRONLY | O_CREAT | O_TRUNC,
     '<<' => O_WRONLY | O_CREAT | O_APPEND,
  );
  
  sub open {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: Can't open() a file with no name"
        unless defined $self->{FILENAME};
     $self->{HANDLE} = gensym unless $self->{HANDLE};
  
     _debug
        "opening '", $self->filename, "' mode '", $self->mode, "'"
     if _debugging_data;
     sysopen(
        $self->{HANDLE},
        $self->filename,
        $open_flags{$self->op},
     ) or croak
           "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
  
     return undef;
  }
  
  
  =item open_pipe
  
  If this is a redirection IO object, this opens the pipe in a platform
  independent manner.
  
  =cut
  
  sub _do_open {
     my $self = shift;
     my ( $child_debug_fd, $parent_handle ) = @_;
  
  
     if ( $self->dir eq "<" ) {
        ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
        if ( $parent_handle ) {
           CORE::open $parent_handle, ">&=$self->{FD}"
              or croak "$! duping write end of pipe for caller";
        }
     }
     else {
        ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
        if ( $parent_handle ) {
           CORE::open $parent_handle, "<&=$self->{FD}"
              or croak "$! duping read end of pipe for caller";
        }
     }
  }
  
  sub open_pipe {
     my IPC::Run::IO $self = shift;
  
     ## Hmmm, Maybe allow named pipes one day.  But until then...
     croak "IPC::Run::IO: Can't pipe() when a file name has been set"
        if defined $self->{FILENAME};
  
     $self->_do_open( @_ );
  
     ## return ( child_fd, parent_fd )
     return $self->dir eq "<"
        ? ( $self->{TFD}, $self->{FD} )
        : ( $self->{FD}, $self->{TFD} );
  }
  
  
  sub _cleanup { ## Called from Run.pm's _cleanup
     my $self = shift;
     undef $self->{FAKE_PIPE};
  }
  
  
  =item close
  
  Closes the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub close {
     my IPC::Run::IO $self = shift;
  
     if ( defined $self->{HANDLE} ) {
        close $self->{HANDLE}
           or croak(  "IPC::Run::IO: $! closing "
              . ( defined $self->{FILENAME}
                 ? "'$self->{FILENAME}'"
                 : "handle"
              )
           );
     }
     else {
        IPC::Run::_close( $self->{FD} );
     }
  
     $self->{FD} = undef;
  
     return undef;
  }
  
  =item fileno
  
  Returns the fileno of the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub fileno {
     my IPC::Run::IO $self = shift;
  
     my $fd = fileno $self->{HANDLE};
     croak(  "IPC::Run::IO: $! "
           . ( defined $self->{FILENAME}
              ? "'$self->{FILENAME}'"
              : "handle"
           )
        ) unless defined $fd;
  
     return $fd;
  }
  
  =item mode
  
  Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
  'ra', unlike Perl's open(), which indicates that data read from the
  handle or file will be appended to the output if the output is a scalar.
  This is only meaningful if the output is a scalar, it has no effect if
  the output is a subroutine.
  
  The redirection operators can be a little confusing, so here's a reference
  table:
  
     >      r      Read from handle in to process
     <      w      Write from process out to handle
     >>     ra     Read from handle in to process, appending it to existing
                   data if the destination is a scalar.
     <<     wa     Write from process out to handle, appending to existing
                   data if IPC::Run::IO opened a named file.
  
  =cut
  
  sub mode {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
  
     ## TODO: Optimize this
     return ( $self->{TYPE} =~ /</     ? 'w' : 'r' ) . 
            ( $self->{TYPE} =~ /<<|>>/ ? 'a' : ''  );
  }
  
  
  =item op
  
  Returns the operation: '<', '>', '<<', '>>'.  See L</mode> if you want
  to spell these 'r', 'w', etc.
  
  =cut
  
  sub op {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
  
     return $self->{TYPE};
  }
  
  =item binmode
  
  Sets/gets whether this pipe is in binmode or not.  No effect off of Win32
  OSs, of course, and on Win32, no effect after the harness is start()ed.
  
  =cut
  
  sub binmode {
     my IPC::Run::IO $self = shift;
  
     $self->{BINMODE} = shift if @_;
  
     return $self->{BINMODE};
  }
  
  
  =item dir
  
  Returns the first character of $self->op.  This is either "<" or ">".
  
  =cut
  
  sub dir {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
  
     return substr $self->{TYPE}, 0, 1;
  }
  
  
  ##
  ## Filter Scaffolding
  ##
  #my $filter_op ;        ## The op running a filter chain right now
  #my $filter_num;        ## Which filter is being run right now.
  
  use vars (
  '$filter_op',        ## The op running a filter chain right now
  '$filter_num'        ## Which filter is being run right now.
  );
  
  sub _init_filters {
     my IPC::Run::IO $self = shift;
  
  confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
     $self->{FBUFS} = [];
  
     $self->{FBUFS}->[0] = $self->{DEST}
        if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
  
     return unless $self->{FILTERS} && @{$self->{FILTERS}};
  
     push @{$self->{FBUFS}}, map {
        my $s = "";
        \$s;
     } ( @{$self->{FILTERS}}, '' );
  
     push @{$self->{FBUFS}}, $self->{SOURCE};
  }
  
  =item poll
  
  TODO: Needs confirmation that this is correct. Was previously undocumented.
  
  I believe this is polling the IO for new input and then returns undef if there will never be any more input, 0 if there is none now, but there might be in the future, and TRUE if more input was gotten.
  
  =cut
  
  sub poll {
     my IPC::Run::IO $self = shift;
     my ( $harness ) = @_;
  
     if ( defined $self->{FD} ) {
        my $d = $self->dir;
        if ( $d eq "<" ) {
           if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
              _debug_desc_fd( "filtering data to", $self )
                 if _debugging_details;
              return $self->_do_filters( $harness );
           }
        }
        elsif ( $d eq ">" ) {
           if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
              _debug_desc_fd( "filtering data from", $self )
                 if _debugging_details;
              return $self->_do_filters( $harness );
           }
        }
     }
     return 0;
  }
  
  
  sub _do_filters {
     my IPC::Run::IO $self = shift;
  
     ( $self->{HARNESS} ) = @_;
  
     my ( $saved_op, $saved_num ) =($IPC::Run::filter_op,$IPC::Run::filter_num);
     $IPC::Run::filter_op = $self;
     $IPC::Run::filter_num = -1;
     my $redos = 0;
     my $r;
     {
  	   $@ = '';
  	   $r = eval { IPC::Run::get_more_input(); };
  
  	   # Detect Resource temporarily unavailable and re-try 200 times (2 seconds),  assuming select behaves (which it doesn't always? need ref)
  	   if(($@||'') =~ $IPC::Run::_EAGAIN && $redos++ < 200) {
  	       select(undef, undef, undef, 0.01);
  	       redo;
  	   }
     }
     ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
     $self->{HARNESS} = undef;
     die "ack ", $@ if $@;
     return $r;
  }
  
  =back
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 TODO
  
  Implement bidirectionality.
  
  =cut
  
  1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = <<'IPC_RUN_TIMER';
  package IPC::Run::Timer;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Timer -- Timer channels for IPC::Run.
  
  =head1 SYNOPSIS
  
     use IPC::Run qw( run  timer timeout );
     ## or IPC::Run::Timer ( timer timeout );
     ## or IPC::Run::Timer ( :all );
  
     ## A non-fatal timer:
     $t = timer( 5 ); # or...
     $t = IO::Run::Timer->new( 5 );
     run $t, ...;
  
     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ); # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" );
  
  =head1 DESCRIPTION
  
  This class and module allows timers and timeouts to be created for use
  by IPC::Run.  A timer simply expires when it's time is up.  A timeout
  is a timer that throws an exception when it expires.
  
  Timeouts are usually a bit simpler to use  than timers: they throw an
  exception on expiration so you don't need to check them:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/;
  
  You do need to check timers:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $t->is_expired || $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired;
  
  Timers and timeouts that are reset get started by start() and
  pump().  Timers change state only in pump().  Since run() and
  finish() both call pump(), they act like pump() with repect to
  timers.
  
  Timers and timeouts have three states: reset, running, and expired.
  Setting the timeout value resets the timer, as does calling
  the reset() method.  The start() method starts (or restarts) a
  timer with the most recently set time value, no matter what state
  it's in.
  
  =head2 Time values
  
  All time values are in seconds.  Times may be specified as integer or
  floating point seconds, optionally preceded by puncuation-separated
  days, hours, and minutes.\
  
  Examples:
  
     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds
  
  Absolute date/time strings are *not* accepted: year, month and
  day-of-month parsing is not available (patches welcome :-).
  
  =head2 Interval fudging
  
  When calculating an end time from a start time and an interval, IPC::Run::Timer
  instances add a little fudge factor.  This is to ensure that no time will
  expire before the interval is up.
  
  First a little background.  Time is sampled in discrete increments.  We'll
  call the
  exact moment that the reported time increments from one interval to the
  next a tick, and the interval between ticks as the time period.  Here's
  a diagram of three ticks and the periods between them:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                   ^                   ^
      |<--- period 0 ---->|<--- period 1 ---->|
      |                   |                   |
    tick 0              tick 1              tick 2
  
  To see why the fudge factor is necessary, consider what would happen
  when a timer with an interval of 1 second is started right at the end of
  period 0:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^                   ^
      |                |  |                   |
      |                |  |                   |
    tick 0             |tick 1              tick 2
                       |
                   start $t
  
  Assuming that check() is called many times per period, then the timer
  is likely to expire just after tick 1, since the time reported will have
  lept from the value '0' to the value '1':
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^   ^               ^
      |                |  |   |               |
      |                |  |   |               |
    tick 0             |tick 1|             tick 2
                       |      |
                   start $t   |
  		            |
  			check $t
  
  Adding a fudge of '1' in this example means that the timer is guaranteed
  not to expire before tick 2.
  
  The fudge is not added to an interval of '0'.
  
  This means that intervals guarantee a minimum interval.  Given that
  the process running perl may be suspended for some period of time, or that
  it gets busy doing something time-consuming, there are no other guarantees on
  how long it will take a timer to expire.
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: Due to the awkwardness introduced by ripping
  pseudohashes out of Perl, this class I<no longer> uses the fields
  pragma.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use Carp;
  use Fcntl;
  use Symbol;
  use Exporter;
  use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
  BEGIN {
  	$VERSION   = '0.90';
  	@ISA       = qw( Exporter );
  	@EXPORT_OK = qw(
  		check
  		end_time
  		exception
  		expire
  		interval
  		is_expired
  		is_reset
  		is_running
  		name
  		reset
  		start
  		timeout
  		timer
  	);
  
  	%EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  }
  
  require IPC::Run;
  use IPC::Run::Debug;
  
  ##
  ## Some helpers
  ##
  my $resolution = 1;
  
  sub _parse_time {
     for ( $_[0] ) {
        return $_ unless defined $_;
        return $_ if /^\d*(?:\.\d*)?$/;
  
        my @f = reverse split( /[^\d\.]+/i );
        croak "IPC::Run: invalid time string '$_'" unless @f <= 4;
        my ( $s, $m, $h, $d ) = @f;
        return
        ( (
  	         ( $d || 0 )   * 24
  	       + ( $h || 0 ) ) * 60
  	       + ( $m || 0 ) ) * 60
                 + ( $s || 0 );
     }
  }
  
  sub _calc_end_time {
     my IPC::Run::Timer $self = shift;
     my $interval = $self->interval;
     $interval += $resolution if $interval;
     $self->end_time( $self->start_time + $interval );
  }
  
  
  =item timer
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timer( 5 );
     $t = timer( 5, name => 'stall timer', debug => 1 );
  
     $t = timer;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timer( 5 );
  
  This convenience function is a shortened spelling of
  
     IPC::Run::Timer->new( ... );
     
  .  It returns a timer in the reset state with a given interval.
  
  If an exception is provided, it will be thrown when the timer notices that
  it has expired (in check()).  The name is for debugging usage, if you plan on
  having multiple timers around.  If no name is provided, a name like "timer #1"
  will be provided.
  
  =cut
  
  sub timer {
     return IPC::Run::Timer->new( @_ );
  }
  
  
  =item timeout
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timeout( 5 );
     $t = timeout( 5, exception => "kablooey" );
     $t = timeout( 5, name => "stall", exception => "kablooey" );
  
     $t = timeout;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timeout( 5 );
  
  A This convenience function is a shortened spelling of 
  
     IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... );
     
  .  It returns a timer in the reset state that will throw an
  exception when it expires.
  
  Takes the same parameters as L</timer>, any exception passed in overrides
  the default exception.
  
  =cut
  
  sub timeout {
     my $t = IPC::Run::Timer->new( @_ );
     $t->exception( "IPC::Run: timeout on " . $t->name )
        unless defined $t->exception;
     return $t;
  }
  
  
  =item new
  
     IPC::Run::Timer->new()  ;
     IPC::Run::Timer->new( 5 )  ;
     IPC::Run::Timer->new( 5, exception => 'kablooey' )  ;
  
  Constructor.  See L</timer> for details.
  
  =cut
  
  my $timer_counter;
  
  
  sub new {
     my $class = shift;
     $class = ref $class || $class;
  
     my IPC::Run::Timer $self = bless {}, $class;
  
     $self->{STATE} = 0;
     $self->{DEBUG} = 0;
     $self->{NAME}  = "timer #" . ++$timer_counter;
  
     while ( @_ ) {
        my $arg = shift;
        if ( $arg =~ /^(?:\d+[^\a\d]){0,3}\d*(?:\.\d*)?$/ ) {
           $self->interval( $arg );
        }
        elsif ( $arg eq 'exception' ) {
           $self->exception( shift );
        }
        elsif ( $arg eq 'name' ) {
           $self->name( shift );
        }
        elsif ( $arg eq 'debug' ) {
           $self->debug( shift );
        }
        else {
           croak "IPC::Run: unexpected parameter '$arg'";
        }
     }
  
     _debug $self->name . ' constructed'
        if $self->{DEBUG} || _debugging_details;
  
     return $self;
  }
  
  =item check
  
     check $t;
     check $t, $now;
     $t->check;
  
  Checks to see if a timer has expired since the last check.  Has no effect
  on non-running timers.  This will throw an exception if one is defined.
  
  IPC::Run::pump() calls this routine for any timers in the harness.
  
  You may pass in a version of now, which is useful in case you have
  it lying around or you want to check several timers with a consistent
  concept of the current time.
  
  Returns the time left before end_time or 0 if end_time is no longer
  in the future or the timer is not running
  (unless, of course, check() expire()s the timer and this
  results in an exception being thrown).
  
  Returns undef if the timer is not running on entry, 0 if check() expires it,
  and the time left if it's left running.
  
  =cut
  
  sub check {
     my IPC::Run::Timer $self = shift;
     return undef if ! $self->is_running;
     return 0     if  $self->is_expired;
  
     my ( $now ) = @_;
     $now = _parse_time( $now );
     $now = time unless defined $now;
  
     _debug(
        "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now 
     ) if $self->{DEBUG} || _debugging_details;
  
     my $left = $self->end_time - $now;
     return $left if $left > 0;
  
     $self->expire;
     return 0;
  }
  
  
  =item debug
  
  Sets/gets the current setting of the debugging flag for this timer.  This
  has no effect if debugging is not enabled for the current harness.
  
  =cut
  
  
  sub debug {
     my IPC::Run::Timer $self = shift;
     $self->{DEBUG} = shift if @_;
     return $self->{DEBUG};
  }
  
  
  =item end_time
  
     $et = $t->end_time;
     $et = end_time $t;
  
     $t->end_time( time + 10 );
  
  Returns the time when this timer will or did expire.  Even if this time is
  in the past, the timer may not be expired, since check() may not have been
  called yet.
  
  Note that this end_time is not start_time($t) + interval($t), since some
  small extra amount of time is added to make sure that the timer does not
  expire before interval() elapses.  If this were not so, then 
  
  Changing end_time() while a timer is running will set the expiration time.
  Changing it while it is expired has no affect, since reset()ing a timer always
  clears the end_time().
  
  =cut
  
  
  sub end_time {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{END_TIME} = shift;
        _debug $self->name, ' end_time set to ', $self->{END_TIME}
  	 if $self->{DEBUG} > 2 || _debugging_details;
     }
     return $self->{END_TIME};
  }
  
  
  =item exception
  
     $x = $t->exception;
     $t->exception( $x );
     $t->exception( undef );
  
  Sets/gets the exception to throw, if any.  'undef' means that no
  exception will be thrown.  Exception does not need to be a scalar: you 
  may ask that references be thrown.
  
  =cut
  
  
  sub exception {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{EXCEPTION} = shift;
        _debug $self->name, ' exception set to ', $self->{EXCEPTION}
  	 if $self->{DEBUG} || _debugging_details;
     }
     return $self->{EXCEPTION};
  }
  
  
  =item interval
  
     $i = interval $t;
     $i = $t->interval;
     $t->interval( $i );
  
  Sets the interval.  Sets the end time based on the start_time() and the
  interval (and a little fudge) if the timer is running.
  
  =cut
  
  sub interval {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{INTERVAL} = _parse_time( shift );
        _debug $self->name, ' interval set to ', $self->{INTERVAL}
  	 if $self->{DEBUG} > 2 || _debugging_details;
  
        $self->_calc_end_time if $self->state;
     }
     return $self->{INTERVAL};
  }
  
  
  =item expire
  
     expire $t;
     $t->expire;
  
  Sets the state to expired (undef).
  Will throw an exception if one
  is defined and the timer was not already expired.  You can expire a
  reset timer without starting it.
  
  =cut
  
  
  sub expire {
     my IPC::Run::Timer $self = shift;
     if ( defined $self->state ) {
        _debug $self->name . ' expired'
  	 if $self->{DEBUG} || _debugging;
  
        $self->state( undef );
        croak $self->exception if $self->exception;
     }
     return undef;
  }
  
  
  =item is_running
  
  =cut
  
  
  sub is_running {
     my IPC::Run::Timer $self = shift;
     return $self->state ? 1 : 0;
  }
  
  
  =item is_reset
  
  =cut
     
  sub is_reset {
     my IPC::Run::Timer $self = shift;
     return defined $self->state && $self->state == 0;
  }
  
  
  =item is_expired
  
  =cut
  
  sub is_expired {
     my IPC::Run::Timer $self = shift;
     return ! defined $self->state;
  }
  
  =item name
  
  Sets/gets this timer's name.  The name is only used for debugging
  purposes so you can tell which freakin' timer is doing what.
  
  =cut
  
  sub name {
     my IPC::Run::Timer $self = shift;
   
     $self->{NAME} = shift if @_;
     return defined $self->{NAME}
        ? $self->{NAME}
        : defined $self->{EXCEPTION}
           ? 'timeout'
  	 : 'timer';
  }
  
  
  =item reset
  
     reset $t;
     $t->reset;
  
  Resets the timer to the non-running, non-expired state and clears
  the end_time().
  
  =cut
  
  sub reset {
     my IPC::Run::Timer $self = shift;
     $self->state( 0 );
     $self->end_time( undef );
     _debug $self->name . ' reset'
        if $self->{DEBUG} || _debugging;
  
     return undef;
  }
  
  
  =item start
  
     start $t;
     $t->start;
     start $t, $interval;
     start $t, $interval, $now;
  
  Starts or restarts a timer.  This always sets the start_time.  It sets the
  end_time based on the interval if the timer is running or if no end time
  has been set.
  
  You may pass an optional interval or current time value.
  
  Not passing a defined interval causes the previous interval setting to be
  re-used unless the timer is reset and an end_time has been set
  (an exception is thrown if no interval has been set).  
  
  Not passing a defined current time value causes the current time to be used.
  
  Passing a current time value is useful if you happen to have a time value
  lying around or if you want to make sure that several timers are started
  with the same concept of start time.  You might even need to lie to an
  IPC::Run::Timer, occasionally.
  
  =cut
  
  sub start {
     my IPC::Run::Timer $self = shift;
  
     my ( $interval, $now ) = map { _parse_time( $_ ) } @_;
     $now = _parse_time( $now );
     $now = time unless defined $now;
  
     $self->interval( $interval ) if defined $interval;
  
     ## start()ing a running or expired timer clears the end_time, so that the
     ## interval is used.  So does specifying an interval.
     $self->end_time( undef ) if ! $self->is_reset || $interval;
  
     croak "IPC::Run: no timer interval or end_time defined for " . $self->name
        unless defined $self->interval || defined $self->end_time;
  
     $self->state( 1 );
     $self->start_time( $now );
     ## The "+ 1" is in case the START_TIME was sampled at the end of a
     ## tick (which are one second long in this module).
     $self->_calc_end_time
        unless defined $self->end_time;
  
     _debug(
        $self->name, " started at ", $self->start_time,
        ", with interval ", $self->interval, ", end_time ", $self->end_time
     ) if $self->{DEBUG} || _debugging;
     return undef;
  }
  
  
  =item start_time
  
  Sets/gets the start time, in seconds since the epoch.  Setting this manually
  is a bad idea, it's better to call L</start>() at the correct time.
  
  =cut
  
  
  sub start_time {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{START_TIME} = _parse_time( shift );
        _debug $self->name, ' start_time set to ', $self->{START_TIME}
  	 if $self->{DEBUG} > 2 || _debugging;
     }
  
     return $self->{START_TIME};
  }
  
  
  =item state
  
     $s = state $t;
     $t->state( $s );
  
  Get/Set the current state.  Only use this if you really need to transfer the
  state to/from some variable.
  Use L</expire>, L</start>, L</reset>, L</is_expired>, L</is_running>,
  L</is_reset>.
  
  Note:  Setting the state to 'undef' to expire a timer will not throw an
  exception.
  
  =back
  
  =cut
  
  sub state {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{STATE} = shift;
        _debug $self->name, ' state set to ', $self->{STATE}
  	 if $self->{DEBUG} > 2 || _debugging;
     }
     return $self->{STATE};
  }
  
  
  1;
  
  =pod
  
  =head1 TODO
  
  use Time::HiRes; if it's present.
  
  Add detection and parsing of [[[HH:]MM:]SS formatted times and intervals.
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =cut
IPC_RUN_TIMER

$fatpacked{"IPC/Run/Win32Helper.pm"} = <<'IPC_RUN_WIN32HELPER';
  package IPC::Run::Win32Helper;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Helper - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32Helper;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select() loop
  will work on Win32. This seems to only work on WinNT and Win2K at this time, not
  sure if it will ever work on Win95 or Win98. If you have experience in this area, please
  contact me at barries@slaysys.com, thanks!.
  
  =cut
  
  use strict;
  use Carp;
  use IO::Handle;
  use vars qw{ $VERSION @ISA @EXPORT };
  BEGIN {
  	$VERSION = '0.90';
  	@ISA = qw( Exporter );
  	@EXPORT = qw(
  		win32_spawn
  		win32_parse_cmd_line
  		_dont_inherit
  		_inherit
  	);
  }
  
  require POSIX;
  
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug;
  use Win32API::File qw(
     FdGetOsFHandle
     SetHandleInformation
     HANDLE_FLAG_INHERIT
     INVALID_HANDLE_VALUE
  );
  
  ## Takes an fd or a GLOB ref, never never never a Win32 handle.
  sub _dont_inherit {
     for ( @_ ) {
        next unless defined $_;
        my $fd = $_;
        $fd = fileno $fd if ref $fd;
        _debug "disabling inheritance of ", $fd if _debugging_details;
        my $osfh = FdGetOsFHandle $fd;
        croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  
        SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
     }
  }
  
  sub _inherit {       #### REMOVE
     for ( @_ ) {       #### REMOVE
        next unless defined $_;       #### REMOVE
        my $fd = $_;       #### REMOVE
        $fd = fileno $fd if ref $fd;       #### REMOVE
        _debug "enabling inheritance of ", $fd if _debugging_details;       #### REMOVE
        my $osfh = FdGetOsFHandle $fd;       #### REMOVE
        croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;       #### REMOVE
         #### REMOVE
        SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );       #### REMOVE
     }       #### REMOVE
  }       #### REMOVE
         #### REMOVE
  #sub _inherit {
  #   for ( @_ ) {
  #      next unless defined $_;
  #      my $osfh = GetOsFHandle $_;
  #      croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  #      SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT );
  #   }
  #}
  
  =pod
  
  =head1 FUNCTIONS
  
  =over
  
  =item optimize()
  
  Most common incantations of C<run()> (I<not> C<harness()>, C<start()>,
  or C<finish()>) now use temporary files to redirect input and output
  instead of pumper processes.
  
  Temporary files are used when sending to child processes if input is
  taken from a scalar with no filter subroutines.  This is the only time
  we can assume that the parent is not interacting with the child's
  redirected input as it runs.
  
  Temporary files are used when receiving from children when output is
  to a scalar or subroutine with or without filters, but only if
  the child in question closes its inputs or takes input from 
  unfiltered SCALARs or named files.  Normally, a child inherits its STDIN
  from its parent; to close it, use "0<&-" or the C<< noinherit => 1 >> option.
  If data is sent to the child from CODE refs, filehandles or from
  scalars through filters than the child's outputs will not be optimized
  because C<optimize()> assumes the parent is interacting with the child.
  It is ok if the output is filtered or handled by a subroutine, however.
  
  This assumes that all named files are real files (as opposed to named
  pipes) and won't change; and that a process is not communicating with
  the child indirectly (through means not visible to IPC::Run).
  These can be an invalid assumptions, but are the 99% case.
  Write me if you need an option to enable or disable optimizations; I
  suspect it will work like the C<binary()> modifier.
  
  To detect cases that you might want to optimize by closing inputs, try
  setting the C<IPCRUNDEBUG> environment variable to the special C<notopt>
  value:
  
     C:> set IPCRUNDEBUG=notopt
     C:> my_app_that_uses_IPC_Run.pl
  
  =item optimizer() rationalizations
  
  Only for that limited case can we be sure that it's ok to batch all the
  input in to a temporary file.  If STDIN is from a SCALAR or from a named
  file or filehandle (again, only in C<run()>), then outputs to CODE refs
  are also assumed to be safe enough to batch through a temp file,
  otherwise only outputs to SCALAR refs are batched.  This can cause a bit
  of grief if the parent process benefits from or relies on a bit of
  "early returns" coming in before the child program exits.  As long as
  the output is redirected to a SCALAR ref, this will not be visible.
  When output is redirected to a subroutine or (deprecated) filters, the
  subroutine will not get any data until after the child process exits,
  and it is likely to get bigger chunks of data at once.
  
  The reason for the optimization is that, without it, "pumper" processes
  are used to overcome the inconsistancies of the Win32 API.  We need to
  use anonymous pipes to connect to the child processes' stdin, stdout,
  and stderr, yet select() does not work on these.  select() only works on
  sockets on Win32.  So for each redirected child handle, there is
  normally a "pumper" process that connects to the parent using a
  socket--so the parent can select() on that fd--and to the child on an
  anonymous pipe--so the child can read/write a pipe.
  
  Using a socket to connect directly to the child (as at least one MSDN
  article suggests) seems to cause the trailing output from most children
  to be lost.  I think this is because child processes rarely close their
  stdout and stderr explicitly, and the winsock dll does not seem to flush
  output when a process that uses it exits without explicitly closing
  them.
  
  Because of these pumpers and the inherent slowness of Win32
  CreateProcess(), child processes with redirects are quite slow to
  launch; so this routine looks for the very common case of
  reading/writing to/from scalar references in a run() routine and
  converts such reads and writes in to temporary file reads and writes.
  
  Such files are marked as FILE_ATTRIBUTE_TEMPORARY to increase speed and
  as FILE_FLAG_DELETE_ON_CLOSE so it will be cleaned up when the child
  process exits (for input files).  The user's default permissions are
  used for both the temporary files and the directory that contains them,
  hope your Win32 permissions are secure enough for you.  Files are
  created with the Win32API::File defaults of
  FILE_SHARE_READ|FILE_SHARE_WRITE.
  
  Setting the debug level to "details" or "gory" will give detailed
  information about the optimization process; setting it to "basic" or
  higher will tell whether or not a given call is optimized.  Setting
  it to "notopt" will highligh those calls that aren't optimized.
  
  =cut
  
  sub optimize {
     my ( $h ) = @_;
  
     my @kids = @{$h->{KIDS}};
  
     my $saw_pipe;
  
     my ( $ok_to_optimize_outputs, $veto_output_optimization );
  
     for my $kid ( @kids ) {
        ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
           unless $saw_pipe;
  
        _debug
           "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
           if _debugging_details && $ok_to_optimize_outputs;
        _debug
           "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
           if _debugging_details && $veto_output_optimization;
  
        if ( $h->{noinherit} && ! $ok_to_optimize_outputs ) {
  	 _debug
  	    "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
  	    if _debugging_details && $ok_to_optimize_outputs;
  	 $ok_to_optimize_outputs = 1;
        }
  
        for ( @{$kid->{OPS}} ) {
           if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
              if ( $_->{TYPE} eq "<" ) {
  	       if ( @{$_->{FILTERS}} > 1 ) {
  		  ## Can't assume that the filters are idempotent.
  	       }
                 elsif ( ref $_->{SOURCE} eq "SCALAR"
  	          || ref $_->{SOURCE} eq "GLOB"
  		  || UNIVERSAL::isa( $_, "IO::Handle" )
  	       ) {
                    if ( $_->{KFD} == 0 ) {
                       _debug
                          "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
                          ref $_->{SOURCE},
                          ", ok to optimize outputs"
                          if _debugging_details;
                       $ok_to_optimize_outputs = 1;
                    }
                    $_->{SEND_THROUGH_TEMP_FILE} = 1;
                    next;
                 }
                 elsif ( ! ref $_->{SOURCE} && defined $_->{SOURCE} ) {
                    if ( $_->{KFD} == 0 ) {
                       _debug
                          "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
                          if _debugging_details;
                       $ok_to_optimize_outputs = 1;
                    }
                    next;
                 }
              }
              _debug
                 "Win32 optimizer: (kid $kid->{NUM}) ",
                 $_->{KFD},
                 $_->{TYPE},
                 defined $_->{SOURCE}
                    ? ref $_->{SOURCE}      ? ref $_->{SOURCE}
                                            : $_->{SOURCE}
                    : defined $_->{FILENAME}
                                            ? $_->{FILENAME}
                                            : "",
  	       @{$_->{FILTERS}} > 1 ? " with filters" : (),
                 ", VETOING output opt."
                 if _debugging_details || _debugging_not_optimized;
              $veto_output_optimization = 1;
           }
           elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
              $ok_to_optimize_outputs = 1;
              _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
                 if _debugging_details;
           }
           elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
              $veto_output_optimization = 1;
              _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
                 if _debugging_details || _debugging_not_optimized;
           }
           elsif ( $_->{TYPE} eq "|" ) {
              $saw_pipe = 1;
           }
        }
  
        if ( ! $ok_to_optimize_outputs && ! $veto_output_optimization ) {
           _debug
              "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
              if _debugging_details || _debugging_not_optimized;
           $veto_output_optimization = 1;
        }
  
        if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
           $ok_to_optimize_outputs = 0;
           _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
              if _debugging_details || _debugging_not_optimized;
        }
  
        ## SOURCE/DEST ARRAY means it's a filter.
        ## TODO: think about checking to see if the final input/output of
        ## a filter chain (an ARRAY SOURCE or DEST) is a scalar...but
        ## we may be deprecating filters.
  
        for ( @{$kid->{OPS}} ) {
           if ( $_->{TYPE} eq ">" ) {
              if ( ref $_->{DEST} eq "SCALAR"
                 || (
                    ( @{$_->{FILTERS}} > 1
  		     || ref $_->{DEST} eq "CODE"
  		     || ref $_->{DEST} eq "ARRAY"  ## Filters?
  	          )
                    && ( $ok_to_optimize_outputs && ! $veto_output_optimization ) 
                 )
              ) {
  	       $_->{RECV_THROUGH_TEMP_FILE} = 1;
  	       next;
              }
  	    _debug
  	       "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
  	       $_->{KFD},
  	       $_->{TYPE},
  	       defined $_->{DEST}
  		  ? ref $_->{DEST}      ? ref $_->{DEST}
  					  : $_->{SOURCE}
  		  : defined $_->{FILENAME}
  					  ? $_->{FILENAME}
  					  : "",
  		  @{$_->{FILTERS}} ? " with filters" : (),
  	       if _debugging_details;
           }
        }
     }
  
  }
  
  =pod
  
  =item win32_parse_cmd_line
  
     @words = win32_parse_cmd_line( q{foo bar 'baz baz' "bat bat"} );
  
  returns 4 words. This parses like the bourne shell (see
  the bit about shellwords() in L<Text::ParseWords>), assuming we're
  trying to be a little cross-platform here.  The only difference is
  that "\" is *not* treated as an escape except when it precedes 
  punctuation, since it's used all over the place in DOS path specs.
  
  TODO: globbing? probably not (it's unDOSish).
  
  TODO: shebang emulation? Probably, but perhaps that should be part
  of Run.pm so all spawned processes get the benefit.
  
  LIMITATIONS: shellwords dies silently on malformed input like 
  
     a\"
  
  =cut
  
  sub win32_parse_cmd_line {
     my $line = shift;
     $line =~ s{(\\[\w\s])}{\\$1}g;
     return shellwords $line;
  }
  
  =pod
  
  =item win32_spawn
  
  Spawns a child process, possibly with STDIN, STDOUT, and STDERR (file descriptors 0, 1, and 2, respectively) redirected.
  
  B<LIMITATIONS>.
  
  Cannot redirect higher file descriptors due to lack of support for this in the
  Win32 environment.
  
  This can be worked around by marking a handle as inheritable in the
  parent (or leaving it marked; this is the default in perl), obtaining it's
  Win32 handle with C<Win32API::GetOSFHandle(FH)> or
  C<Win32API::FdGetOsFHandle($fd)> and passing it to the child using the command
  line, the environment, or any other IPC mechanism (it's a plain old integer).
  The child can then use C<OsFHandleOpen()> or C<OsFHandleOpenFd()> and possibly
  C<<open FOO ">&BAR">> or C<<open FOO ">&$fd>> as need be.  Ach, the pain!
  
  Remember to check the Win32 handle against INVALID_HANDLE_VALUE.
  
  =cut
  
  sub _save {
     my ( $saved, $saved_as, $fd ) = @_;
  
     ## We can only save aside the original fds once.
     return if exists $saved->{$fd};
  
     my $saved_fd = IPC::Run::_dup( $fd );
     _dont_inherit $saved_fd;
  
     $saved->{$fd} = $saved_fd;
     $saved_as->{$saved_fd} = $fd;
  
     _dont_inherit $saved->{$fd};
  }
  
  sub _dup2_gently {
     my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
     _save $saved, $saved_as, $fd2;
  
     if ( exists $saved_as->{$fd2} ) {
        ## The target fd is colliding with a saved-as fd, gotta bump
        ## the saved-as fd to another fd.
        my $orig_fd = delete $saved_as->{$fd2};
        my $saved_fd = IPC::Run::_dup( $fd2 );
        _dont_inherit $saved_fd;
  
        $saved->{$orig_fd} = $saved_fd;
        $saved_as->{$saved_fd} = $orig_fd;
     }
     _debug "moving $fd1 to kid's $fd2" if _debugging_details;
     IPC::Run::_dup2_rudely( $fd1, $fd2 );
  }
  
  sub win32_spawn {
     my ( $cmd, $ops) = @_;
  
     ## NOTE: The debug pipe write handle is passed to pump processes as STDOUT.
     ## and is not to the "real" child process, since they would not know
     ## what to do with it...unlike Unix, we have no code executing in the
     ## child before the "real" child is exec()ed.
     
     my %saved;      ## Map of parent's orig fd -> saved fd
     my %saved_as;   ## Map of parent's saved fd -> orig fd, used to
                      ## detect collisions between a KFD and the fd a
  		    ## parent's fd happened to be saved to.
     
     for my $op ( @$ops ) {
        _dont_inherit $op->{FD}  if defined $op->{FD};
  
        if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
  	 ## TODO: Detect this in harness()
  	 ## TODO: enable temporary redirections if ever necessary, not
  	 ## sure why they would be...
  	 ## 4>&1 1>/dev/null 1>&4 4>&-
           croak "Can't redirect fd #", $op->{KFD}, " on Win32";
        }
  
        ## This is very similar logic to IPC::Run::_do_kid_and_exit().
        if ( defined $op->{TFD} ) {
  	 unless ( $op->{TFD} == $op->{KFD} ) {
  	    _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
  	    _dont_inherit $op->{TFD};
  	 }
        }
        elsif ( $op->{TYPE} eq "dup" ) {
           _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
              unless $op->{KFD1} == $op->{KFD2};
        }
        elsif ( $op->{TYPE} eq "close" ) {
  	 _save \%saved, \%saved_as, $op->{KFD};
  	 IPC::Run::_close( $op->{KFD} );
        }
        elsif ( $op->{TYPE} eq "init" ) {
  	 ## TODO: detect this in harness()
           croak "init subs not allowed on Win32";
        }
     }
  
     my $process;
     my $cmd_line = join " ", map {
        ( my $s = $_ ) =~ s/"/"""/g;
        $s = qq{"$s"} if /[\"\s]/;
        $s;
     } @$cmd;
  
     _debug "cmd line: ", $cmd_line
        if _debugging;
  
     Win32::Process::Create( 
        $process,
        $cmd->[0],
        $cmd_line,
        1,  ## Inherit handles
        NORMAL_PRIORITY_CLASS,
        ".",
     ) or croak "$!: Win32::Process::Create()";
  
     for my $orig_fd ( keys %saved ) {
        IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
        IPC::Run::_close( $saved{$orig_fd} );
     }
  
     return ( $process->GetProcessID(), $process );
  }
  
  
  1;
  
  =pod
  
  =back
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32HELPER

$fatpacked{"IPC/Run/Win32IO.pm"} = <<'IPC_RUN_WIN32IO';
  package IPC::Run::Win32IO;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32IO - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32IO;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select()
  loop will work on Win32. This seems to only work on WinNT and Win2K at this
  time, not sure if it will ever work on Win95 or Win98. If you have experience
  in this area, please contact me at barries@slaysys.com, thanks!.
  
  =head1 DESCRIPTION
  
  A specialized IO class used on Win32.
  
  =cut
  
  use strict;
  use Carp;
  use IO::Handle;
  use Socket;
  require POSIX;
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '0.90';
  }
  
  use Socket qw( IPPROTO_TCP TCP_NODELAY );
  use Symbol;
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug qw( :default _debugging_level );
  use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
  use Fcntl qw( O_TEXT O_RDONLY );
  
  use base qw( IPC::Run::IO );
  my @cleanup_fields;
  BEGIN {
     ## These fields will be set to undef in _cleanup to close
     ## the handles.
     @cleanup_fields = (
        'SEND_THROUGH_TEMP_FILE', ## Set by WinHelper::optimize()
        'RECV_THROUGH_TEMP_FILE', ## Set by WinHelper::optimize()
        'TEMP_FILE_NAME',         ## The name of the temp file, needed for
                                  ## error reporting / debugging only.
  
        'PARENT_HANDLE',       ## The handle of the socket for the parent
        'PUMP_SOCKET_HANDLE',  ## The socket handle for the pump
        'PUMP_PIPE_HANDLE',    ## The anon pipe handle for the pump
        'CHILD_HANDLE',        ## The anon pipe handle for the child
  
        'TEMP_FILE_HANDLE',    ## The Win32 filehandle for the temp file
     );
  }
  
  ## REMOVE OSFHandleOpen
  use Win32API::File qw(
     GetOsFHandle
     OsFHandleOpenFd
     OsFHandleOpen
     FdGetOsFHandle
     SetHandleInformation
     SetFilePointer
     HANDLE_FLAG_INHERIT
     INVALID_HANDLE_VALUE
  
     createFile
     WriteFile
     ReadFile
     CloseHandle
  
     FILE_ATTRIBUTE_TEMPORARY
     FILE_FLAG_DELETE_ON_CLOSE
     FILE_FLAG_WRITE_THROUGH
  
     FILE_BEGIN
  );
  
  #   FILE_ATTRIBUTE_HIDDEN
  #   FILE_ATTRIBUTE_SYSTEM
  
  
  BEGIN {
     ## Force AUTOLOADED constants to be, well, constant by getting them
     ## to AUTOLOAD before compilation continues.  Sigh.
     () = (
        SOL_SOCKET,
        SO_REUSEADDR,
        IPPROTO_TCP,
        TCP_NODELAY,
        HANDLE_FLAG_INHERIT,
        INVALID_HANDLE_VALUE,
     );
  }
  
  use constant temp_file_flags => (
     FILE_ATTRIBUTE_TEMPORARY()   |
     FILE_FLAG_DELETE_ON_CLOSE()  |
     FILE_FLAG_WRITE_THROUGH()
  );
  
  #   FILE_ATTRIBUTE_HIDDEN()    |
  #   FILE_ATTRIBUTE_SYSTEM()    |
  my $tmp_file_counter;
  my $tmp_dir;
  
  sub _cleanup {
      my IPC::Run::Win32IO $self = shift;
      my ( $harness ) = @_;
  
      $self->_recv_through_temp_file( $harness )
         if $self->{RECV_THROUGH_TEMP_FILE};
  
      CloseHandle( $self->{TEMP_FILE_HANDLE} )
         if defined $self->{TEMP_FILE_HANDLE};
  
      $self->{$_} = undef for @cleanup_fields;
  }
  
  
  sub _create_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     ## Create a hidden temp file that Win32 will delete when we close
     ## it.
     unless ( defined $tmp_dir ) {
        $tmp_dir = File::Spec->catdir(
           File::Spec->tmpdir, "IPC-Run.tmp"
        );
  
        ## Trust in the user's umask.
        ## This could possibly be a security hole, perhaps
        ## we should offer an option.  Hmmmm, really, people coding
        ## security conscious apps should audit this code and
        ## tell me how to make it better.  Nice cop-out :).
        unless ( -d $tmp_dir ) {
           mkdir $tmp_dir or croak "$!: $tmp_dir";
        }
     }
  
     $self->{TEMP_FILE_NAME} = File::Spec->catfile(
        ## File name is designed for easy sorting and not conflicting
        ## with other processes.  This should allow us to use "t"runcate
        ## access in CreateFile in case something left some droppings
        ## around (which should never happen because we specify
        ## FLAG_DELETE_ON_CLOSE.
        ## heh, belt and suspenders are better than bug reports; God forbid
        ## that NT should ever crash before a temp file gets deleted!
        $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
     );
  
     $self->{TEMP_FILE_HANDLE} = createFile(
        $self->{TEMP_FILE_NAME},
        "trw",         ## new, truncate, read, write
        {
           Flags      => temp_file_flags,
        },
     ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
  
     $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
     $self->{FD} = undef;
  
     _debug
        "Win32 Optimizer: temp file (",
        $self->{KFD},
        $self->{TYPE},
        $self->{TFD},
        ", fh ",
        $self->{TEMP_FILE_HANDLE},
        "): ",
        $self->{TEMP_FILE_NAME}
        if _debugging_details;
  }
  
  
  sub _reset_temp_file_pointer {
     my $self = shift;
     SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
        or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
  }
  
  
  sub _send_through_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     _debug
        "Win32 optimizer: optimizing "
        . " $self->{KFD} $self->{TYPE} temp file instead of ",
           ref $self->{SOURCE} || $self->{SOURCE}
        if _debugging_details;
  
     $self->_create_temp_file;
  
     if ( defined ${$self->{SOURCE}} ) {
        my $bytes_written = 0;
        my $data_ref;
        if ( $self->binmode ) {
  	 $data_ref = $self->{SOURCE};
        }
        else {
           my $data = ${$self->{SOURCE}};  # Ugh, a copy.
  	 $data =~ s/(?<!\r)\n/\r\n/g;
  	 $data_ref = \$data;
        }
  
        WriteFile(
           $self->{TEMP_FILE_HANDLE},
           $$data_ref,
           0,              ## Write entire buffer
           $bytes_written,
           [],             ## Not overlapped.
        ) or croak
           "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
        _debug
           "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
           if _debugging_data;
  
        $self->_reset_temp_file_pointer;
  
     }
  
  
     _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
        if _debugging_details;
  }
  
  
  sub _init_recv_through_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     $self->_create_temp_file;
  }
  
  
  ## TODO: USe the Win32 API in the select loop to see if the file has grown
  ## and read it incrementally if it has.
  sub _recv_through_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     ## This next line kicks in if the run() never got to initting things
     ## and needs to clean up.
     return undef unless defined $self->{TEMP_FILE_HANDLE};
  
     push @{$self->{FILTERS}}, sub {
        my ( undef, $out_ref ) = @_;
  
        return undef unless defined $self->{TEMP_FILE_HANDLE};
  
        my $r;
        my $s;
        ReadFile(
  	 $self->{TEMP_FILE_HANDLE},
  	 $s,
  	 999_999,  ## Hmmm, should read the size.
  	 $r,
  	 []
        ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
  
        _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
  
        return undef unless $r;
  
        $s =~ s/\r\n/\n/g unless $self->binmode;
  
        my $pos = pos $$out_ref;
        $$out_ref .= $s;
        pos( $out_ref ) = $pos;
        return 1;
     };
  
     my ( $harness ) = @_;
  
     $self->_reset_temp_file_pointer;
  
     1 while $self->_do_filters( $harness );
  
     pop @{$self->{FILTERS}};
  
     IPC::Run::_close( $self->{TFD} );
  }
  
  =head1 SUBROUTINES
  
  =over
  
  =item poll
  
  Windows version of IPC::Run::IP::poll.
  
  =back
  
  =cut
  
  sub poll {
     my IPC::Run::Win32IO $self = shift;
  
     return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
  
     return $self->SUPER::poll( @_ );
  }
  
  
  ## When threaded Perls get good enough, we should use threads here.
  ## The problem with threaded perls is that they dup() all sorts of
  ## filehandles and fds and don't allow sufficient control over
  ## closing off the ones we don't want.
  
  sub _spawn_pumper {
     my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
     my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
  
     _debug "pumper stdin = ", $stdin_fd if _debugging_details;
     _debug "pumper stdout = ", $stdout_fd if _debugging_details;
     _inherit $stdin_fd, $stdout_fd, $debug_fd;
     my @I_options = map qq{"-I$_"}, @INC;
  
     my $cmd_line = join( " ",
        qq{"$^X"},
        @I_options,
        qw(-MIPC::Run::Win32Pump -e 1 ),
  ## I'm using this clunky way of passing filehandles to the child process
  ## in order to avoid some kind of premature closure of filehandles
  ## problem I was having with VCP's test suite when passing them
  ## via CreateProcess.  All of the ## REMOVE code is stuff I'd like
  ## to be rid of and the ## ADD code is what I'd like to use.
        FdGetOsFHandle( $stdin_fd ), ## REMOVE
        FdGetOsFHandle( $stdout_fd ), ## REMOVE
        FdGetOsFHandle( $debug_fd ), ## REMOVE
        $binmode ? 1 : 0,
        $$, $^T, _debugging_level, qq{"$child_label"},
        @opts
     );
  
  #   open SAVEIN,  "<&STDIN"  or croak "$! saving STDIN";       #### ADD
  #   open SAVEOUT, ">&STDOUT" or croak "$! saving STDOUT";       #### ADD
  #   open SAVEERR, ">&STDERR" or croak "$! saving STDERR";       #### ADD
  #   _dont_inherit \*SAVEIN;       #### ADD
  #   _dont_inherit \*SAVEOUT;       #### ADD
  #   _dont_inherit \*SAVEERR;       #### ADD
  #   open STDIN,  "<&$stdin_fd"  or croak "$! dup2()ing $stdin_fd (pumper's STDIN)";       #### ADD
  #   open STDOUT, ">&$stdout_fd" or croak "$! dup2()ing $stdout_fd (pumper's STDOUT)";       #### ADD
  #   open STDERR, ">&$debug_fd" or croak "$! dup2()ing $debug_fd (pumper's STDERR/debug_fd)";       #### ADD
  
     _debug "pump cmd line: ", $cmd_line if _debugging_details;
  
     my $process;
     Win32::Process::Create( 
        $process,
        $^X,
        $cmd_line,
        1,  ## Inherit handles
        NORMAL_PRIORITY_CLASS,
        ".",
     ) or croak "$!: Win32::Process::Create()";
  
  #   open STDIN,  "<&SAVEIN"  or croak "$! restoring STDIN";       #### ADD
  #   open STDOUT, ">&SAVEOUT" or croak "$! restoring STDOUT";       #### ADD
  #   open STDERR, ">&SAVEERR" or croak "$! restoring STDERR";       #### ADD
  #   close SAVEIN             or croak "$! closing SAVEIN";       #### ADD
  #   close SAVEOUT            or croak "$! closing SAVEOUT";       #### ADD
  #   close SAVEERR            or croak "$! closing SAVEERR";       #### ADD
  
     close $stdin  or croak "$! closing pumper's stdin in parent";
     close $stdout or croak "$! closing pumper's stdout in parent";
     # Don't close $debug_fd, we need it, as do other pumpers.
  
     # Pause a moment to allow the child to get up and running and emit
     # debug messages.  This does not always work.
     #   select undef, undef, undef, 1 if _debugging_details;
  
     _debug "_spawn_pumper pid = ", $process->GetProcessID 
        if _debugging_data;
  }
  
  
  my $next_port = 2048;
  my $loopback  = inet_aton "127.0.0.1";
  my $tcp_proto = getprotobyname('tcp');
  croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
  
  sub _socket {
     my ( $server ) = @_;
     $server ||= gensym;
     my $client = gensym;
  
     my $listener = gensym;
     socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
        or croak "$!: socket()";
     setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack("l", 0)
        or croak "$!: setsockopt()";
  
     my $port;
     my @errors;
  PORT_FINDER_LOOP:
     {
        $port = $next_port;
        $next_port = 2048 if ++$next_port > 65_535; 
        unless ( bind $listener, sockaddr_in( $port, $loopback ) ) {
  	 push @errors, "$! on port $port";
  	 croak join "\n", @errors if @errors > 10;
           goto PORT_FINDER_LOOP;
        }
     }
  
     _debug "win32 port = $port" if _debugging_details;
  
     listen $listener, my $queue_size = 1
        or croak "$!: listen()";
  
     {
        socket $client, PF_INET, SOCK_STREAM, $tcp_proto
           or croak "$!: socket()";
  
        my $paddr = sockaddr_in($port, $loopback );
  
        connect $client, $paddr
           or croak "$!: connect()";
      
        croak "$!: accept" unless defined $paddr;
  
        ## The windows "default" is SO_DONTLINGER, which should make
        ## sure all socket data goes through.  I have my doubts based
        ## on experimentation, but nothing prompts me to set SO_LINGER
        ## at this time...
        setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack("l", 0)
  	 or croak "$!: setsockopt()";
     }
  
     {
        _debug "accept()ing on port $port" if _debugging_details;
        my $paddr = accept( $server, $listener );
        croak "$!: accept()" unless defined $paddr;
     }
  
     _debug
        "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port" 
        if _debugging_details;
     return ( $server, $client );
  }
  
  
  sub _open_socket_pipe {
     my IPC::Run::Win32IO $self = shift;
     my ( $debug_fd, $parent_handle ) = @_;
  
     my $is_send_to_child = $self->dir eq "<";
  
     $self->{CHILD_HANDLE}     = gensym;
     $self->{PUMP_PIPE_HANDLE} = gensym;
  
     ( 
        $self->{PARENT_HANDLE},
        $self->{PUMP_SOCKET_HANDLE}
     ) = _socket $parent_handle;
  
     ## These binmodes seem to have no effect on Win2K, but just to be safe
     ## I do them.
     binmode $self->{PARENT_HANDLE}      or die $!;
     binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
  
  _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
     if _debugging_details;
  ##my $buf;
  ##$buf = "write on child end of " . fileno( $self->{WRITE_HANDLE} ) . "\n\n\n\n\n";
  ##POSIX::write(fileno $self->{WRITE_HANDLE}, $buf, length $buf) or warn "$! in syswrite";
  ##$buf = "write on parent end of " . fileno( $self->{CHILD_HANDLE} ) . "\r\n";
  ##POSIX::write(fileno $self->{CHILD_HANDLE},$buf, length $buf) or warn "$! in syswrite";
  ##   $self->{CHILD_HANDLE}->autoflush( 1 );
  ##   $self->{WRITE_HANDLE}->autoflush( 1 );
  
     ## Now fork off a data pump and arrange to return the correct fds.
     if ( $is_send_to_child ) {
        pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
           or croak "$! opening child pipe";
  _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
     if _debugging_details;
  _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
     if _debugging_details;
     }
     else {
        pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
           or croak "$! opening child pipe";
  _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
     if _debugging_details;
  _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
     if _debugging_details;
     }
  
     ## These binmodes seem to have no effect on Win2K, but just to be safe
     ## I do them.
     binmode $self->{CHILD_HANDLE};
     binmode $self->{PUMP_PIPE_HANDLE};
  
     ## No child should ever see this.
     _dont_inherit $self->{PARENT_HANDLE};
  
     ## We clear the inherit flag so these file descriptors are not inherited.
     ## It'll be dup()ed on to STDIN/STDOUT/STDERR before CreateProcess is
     ## called and *that* fd will be inheritable.
     _dont_inherit $self->{PUMP_SOCKET_HANDLE};
     _dont_inherit $self->{PUMP_PIPE_HANDLE};
     _dont_inherit $self->{CHILD_HANDLE};
  
     ## Need to return $self so the HANDLEs don't get freed.
     ## Return $self, $parent_fd, $child_fd
     my ( $parent_fd, $child_fd ) = (
        fileno $self->{PARENT_HANDLE},
        fileno $self->{CHILD_HANDLE}
     );
  
     ## Both PUMP_..._HANDLEs will be closed, no need to worry about
     ## inheritance.
     _debug "binmode on" if _debugging_data && $self->binmode;
     _spawn_pumper(
        $is_send_to_child
  	 ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
  	 : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
        $debug_fd,
        $self->binmode,
        $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
     );
  
  {
  my $foo;
  confess "PARENT_HANDLE no longer open"
     unless POSIX::read( $parent_fd, $foo, 0 );
  }
  
     _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
        if _debugging_details;
  
     $self->{FD}  = $parent_fd;
     $self->{TFD} = $child_fd;
  }
  
  sub _do_open {
     my IPC::Run::Win32IO $self = shift;
  
     if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
        return $self->_send_through_temp_file( @_ );
     }
     elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
        return $self->_init_recv_through_temp_file( @_ );
     }
     else {
        return $self->_open_socket_pipe( @_ );
     }
  }
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32IO

$fatpacked{"IPC/Run/Win32Pump.pm"} = <<'IPC_RUN_WIN32PUMP';
  package IPC::Run::Win32Pump;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Pump - helper processes to shovel data to/from parent, child
  
  =head1 SYNOPSIS
  
  Internal use only; see IPC::Run::Win32IO and best of luck to you.
  
  =head1 DESCRIPTION
  
  See L<IPC::Run::Win32Helper|IPC::Run::Win32Helper> for details.  This
  module is used in subprocesses that are spawned to shovel data to/from
  parent processes from/to their child processes.  Where possible, pumps
  are optimized away.
  
  NOTE: This is not a real module: it's a script in module form, designed
  to be run like
  
     $^X -MIPC::Run::Win32Pumper -e 1 ...
  
  It parses a bunch of command line parameters from IPC::Run::Win32IO.
  
  =cut
  
  use strict;
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '0.90';
  }
  
  use Win32API::File qw(
     OsFHandleOpen
  );
  
  
  my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
  BEGIN {
     ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
     ## Rather than letting IPC::Run::Debug export all-0 constants
     ## when not debugging, we do it manually in order to not even
     ## load IPC::Run::Debug.
     if ( $debug ) {
        eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
  	 or die $@;
     }
     else {
        eval <<STUBS_END or die $@;
  	 sub _debug {}
  	 sub _debug_init {}
  	 sub _debugging() { 0 }
  	 sub _debugging_data() { 0 }
  	 sub _debugging_details() { 0 }
  	 sub _debugging_gory_details() { 0 }
  	 1;
  STUBS_END
     }
  }
  
  ## For some reason these get created with binmode on.  AAargh, gotta       #### REMOVE
  ## do it by hand below.       #### REMOVE
  if ( $debug ) {       #### REMOVE
  close STDERR;       #### REMOVE
  OsFHandleOpen( \*STDERR, $debug_fh, "w" )       #### REMOVE
   or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";       #### REMOVE
  }       #### REMOVE
  close STDIN;       #### REMOVE
  OsFHandleOpen( \*STDIN, $stdin_fh, "r" )       #### REMOVE
  or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";       #### REMOVE
  close STDOUT;       #### REMOVE
  OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )       #### REMOVE
  or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";       #### REMOVE
  
  binmode STDIN;
  binmode STDOUT;
  $| = 1;
  select STDERR; $| = 1; select STDOUT;
  
  $child_label ||= "pump";
  _debug_init(
  $parent_pid,
  $parent_start_time,
  $debug,
  fileno STDERR,
  $child_label,
  );
  
  _debug "Entered" if _debugging_details;
  
  # No need to close all fds; win32 doesn't seem to pass any on to us.
  $| = 1;
  my $buf;
  my $total_count = 0;
  while (1) {
  my $count = sysread STDIN, $buf, 10_000;
  last unless $count;
  if ( _debugging_gory_details ) {
   my $msg = "'$buf'";
   substr( $msg, 100, -1 ) = '...' if length $msg > 100;
   $msg =~ s/\n/\\n/g;
   $msg =~ s/\r/\\r/g;
   $msg =~ s/\t/\\t/g;
   $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
   _debug sprintf( "%5d chars revc: ", $count ), $msg;
  }
  $total_count += $count;
  $buf =~ s/\r//g unless $binmode;
  if ( _debugging_gory_details ) {
   my $msg = "'$buf'";
   substr( $msg, 100, -1 ) = '...' if length $msg > 100;
   $msg =~ s/\n/\\n/g;
   $msg =~ s/\r/\\r/g;
   $msg =~ s/\t/\\t/g;
   $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
   _debug sprintf( "%5d chars sent: ", $count ), $msg;
  }
  print $buf;
  }
  
  _debug "Exiting, transferred $total_count chars" if _debugging_details;
  
  ## Perform a graceful socket shutdown.  Windows defaults to SO_DONTLINGER,
  ## which should cause a "graceful shutdown in the background" on sockets.
  ## but that's only true if the process closes the socket manually, it
  ## seems; if the process exits and lets the OS clean up, the OS is not
  ## so kind.  STDOUT is not always a socket, of course, but it won't hurt
  ## to close a pipe and may even help.  With a closed source OS, who
  ## can tell?
  ##
  ## In any case, this close() is one of the main reasons we have helper
  ## processes; if the OS closed socket fds gracefully when an app exits,
  ## we'd just redirect the client directly to what is now the pump end 
  ## of the socket.  As it is, however, we need to let the client play with
  ## pipes, which don't have the abort-on-app-exit behavior, and then
  ## adapt to the sockets in the helper processes to allow the parent to
  ## select.
  ##
  ## Possible alternatives / improvements:
  ## 
  ## 1) use helper threads instead of processes.  I don't trust perl's threads
  ## as of 5.005 or 5.6 enough (which may be myopic of me).
  ##
  ## 2) figure out if/how to get at WaitForMultipleObjects() with pipe
  ## handles.  May be able to take the Win32 handle and pass it to 
  ## Win32::Event::wait_any, dunno.
  ## 
  ## 3) Use Inline::C or a hand-tooled XS module to do helper threads.
  ## This would be faster than #1, but would require a ppm distro.
  ##
  close STDOUT;
  close STDERR;
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32PUMP

$fatpacked{"darwin-2level/Cwd.pm"} = <<'DARWIN-2LEVEL_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.40';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $xs_version );
    }
  };
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd_simple {
      $ENV{'PWD'} = `cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      # Need to avoid taking any sort of reference to the typeglob or the code in
      # the optree, so that this tests the runtime state of things, as the
      # ExtUtils::MakeMaker tests for "miniperl" need to be able to fake things at
      # runtime by deleting the subroutine. *foo{THING} syntax on a symbol table
      # lookup avoids needing a string eval, which has been reported to cause
      # problems (for reasons that we haven't been able to get to the bottom of -
      # rt.cpan.org #56225)
      if (*{$DynaLoader::{boot_DynaLoader}}{CODE}) {
  	$ENV{'PWD'} = Win32::GetCwd();
      }
      else { # miniperl
  	chomp($ENV{'PWD'} = `cd`);
      }
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
DARWIN-2LEVEL_CWD

$fatpacked{"darwin-2level/File/Spec.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC

$fatpacked{"darwin-2level/File/Spec/Cygwin.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_CYGWIN

$fatpacked{"darwin-2level/File/Spec/Epoc.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_EPOC

$fatpacked{"darwin-2level/File/Spec/Functions.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS

$fatpacked{"darwin-2level/File/Spec/Mac.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_MAC

$fatpacked{"darwin-2level/File/Spec/OS2.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC_OS2

$fatpacked{"darwin-2level/File/Spec/Unix.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
  	elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	    @dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
      # For UNC paths, the user might give a volume like //foo/bar that
      # strictly speaking has no directory portion.  Treat it as if it
      # had the root directory for that volume.
      if (!length($base_directories) and $self->file_name_is_absolute($base)) {
        $base_directories = $self->rootdir;
      }
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
DARWIN-2LEVEL_FILE_SPEC_UNIX

$fatpacked{"darwin-2level/File/Spec/VMS.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicity requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
              }
  
  	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	    # Special case for VMS absolute directory specs: these will have
  	    # had device prepended during trip through Unix syntax in
  	    # eliminate_macros(), since Unix syntax has no way to express
  	    # "absolute from the top of this device's directory tree".
  	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
                  } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
              } else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
  		$rslt = $self->eliminate_macros($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $file : vmsify($file);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
          my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
          $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
            $dir = vmspath($dir);
        }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if grep m{/}, @_;
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
          if ($path =~ m/\//) {
  	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
  		       ? vmspath($path)             # whether it's a directory
  		       : vmsify($path) );
          }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
              $sep = '.'
                  if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                       $path_directories =~ m{^[^.\[<]}s
                  ) ;
              $base_directories = "$base_directories$sep$path_directories";
              $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_VMS

$fatpacked{"darwin-2level/File/Spec/Win32.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
DARWIN-2LEVEL_FILE_SPEC_WIN32

$fatpacked{"darwin-2level/List/MoreUtils.pm"} = <<'DARWIN-2LEVEL_LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.00503;
  use strict;
  use Exporter   ();
  use DynaLoader ();
  
  use vars qw{ $VERSION @ISA @EXPORT_OK %EXPORT_TAGS };
  BEGIN {
      $VERSION   = '0.33';
      # $VERSION   = eval $VERSION;
      @ISA       = qw{ Exporter DynaLoader };
      @EXPORT_OK = qw{
          any all none notall true false
          firstidx first_index lastidx last_index
          insert_after insert_after_string
          apply indexes
          after after_incl before before_incl
          firstval first_value lastval last_value
          each_array each_arrayref
          pairwise natatime
          mesh zip uniq distinct
          minmax part
      };
      %EXPORT_TAGS = (
          all => \@EXPORT_OK,
      );
  
      # Load the XS at compile-time so that redefinition warnings will be
      # thrown correctly if the XS versions of part or indexes loaded
      eval {
          # PERL_DL_NONLAZY must be false, or any errors in loading will just
          # cause the perl code to be tested
          local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  
          bootstrap List::MoreUtils $VERSION;
          1;
  
      } unless $ENV{LIST_MOREUTILS_PP};
  }
  
  eval <<'END_PERL' unless defined &any;
  
  # Use pure scalar boolean return values for compatibility with XS
  use constant YES => ! 0;
  use constant NO  => ! 1;
  
  sub any (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES if $f->();
      }
      return NO;
  }
  
  sub all (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO unless $f->();
      }
      return YES;
  }
  
  sub none (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO if $f->();
      }
      return YES;
  }
  
  sub notall (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES unless $f->();
      }
      return NO;
  }
  
  sub true (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ if $f->();
      }
      return $count;
  }
  
  sub false (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ unless $f->();
      }
      return $count;
  }
  
  sub firstidx (&@) {
      my $f = shift;
      foreach my $i ( 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastidx (&@) {
      my $f = shift;
      foreach my $i ( reverse 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub insert_after (&$\@) {
      my ($f, $val, $list) = @_;
      my $c = -1;
      local *_;
      foreach my $i ( 0 .. $#$list ) {
          $_ = $list->[$i];
          $c = $i, last if $f->();
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@) {
      my ($string, $val, $list) = @_;
      my $c = -1;
      foreach my $i ( 0 .. $#$list ) {
          local $^W = 0;
          $c = $i, last if $string eq $list->[$i];
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@) {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@) {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do {
          my $x = $lag;
          $lag = $test->();
          $x
      }, @_;
  }
  
  sub after_incl (&@) {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@) {
      my $test = shift;
      my $more = 1;
      grep $more &&= ! $test->(), @_;
  }
  
  sub before_incl (&@) {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do {
          my $x = $lag;
          $lag = ! $test->();
          $x
      }, @_;
  }
  
  sub indexes (&@) {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub lastval (&@) {
      my $test = shift;
      my $ix;
      for ( $ix = $#_; $ix >= 0; $ix-- ) {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub firstval (&@) {
      my $test = shift;
      foreach ( @_ ) {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub pairwise (&\@\@) {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local ( *A, *B ) = @_;
  
      # Localise $a, $b
      my ( $caller_a, $caller_b ) = do {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg.'::a'}, \*{$pkg.'::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B? $#A : $#B;
  
      # This map expression is also the return value
      local( *$caller_a, *$caller_b );
      map {
          # Assign to $a, $b as refs to caller's array elements
          ( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );
  
          # Perform the transformation
          $op->();
      }  0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      return each_arrayref(@_);
  }
  
  sub each_arrayref {
      my @list  = @_; # The list of references to the arrays
      my $index = 0;  # Which one the caller will get next
      my $max   = 0;  # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach ( @list ) {
          unless ( ref $_ eq 'ARRAY' ) {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if ( @_ ) {
              my $method = shift;
              unless ( $method eq 'index' ) {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0  ||  $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list; 
      }
  }
  
  sub natatime ($@) {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
      }
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      my $max = -1;
      $max < $#$_ && ( $max = $#$_ ) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max; 
  }
  
  sub uniq (@) {
      my %seen = ();
      grep { not $seen{$_}++ } @_;
  }
  
  sub minmax (@) {
      return unless @_;
      my $min = my $max = $_[0];
  
      for ( my $i = 1; $i < @_; $i += 2 ) {
          if ( $_[$i-1] <= $_[$i] ) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      if ( @_ & 1 ) {
          my $i = $#_;
          if ($_[$i-1] <= $_[$i]) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@) {
      my ($code, @list) = @_;
      my @parts;
      push @{ $parts[ $code->($_) ] }, $_  foreach @list;
      return @parts;
  }
  
  sub _XScompiled {
      return 0;
  }
  
  END_PERL
  die $@ if $@;
  
  # Function aliases
  *first_index = \&firstidx;
  *last_index  = \&lastidx;
  *first_value = \&firstval;
  *last_value  = \&lastval;
  *zip         = \&mesh;
  *distinct    = \&uniq;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      use List::MoreUtils qw{
          any all none notall true false
          firstidx first_index lastidx last_index
          insert_after insert_after_string
          apply indexes
          after after_incl before before_incl
          firstval first_value lastval last_value
          each_array each_arrayref
          pairwise natatime
          mesh zip uniq distinct minmax part
      };
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =over 4
  
  =item any BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "At least one value undefined"
          if any { ! defined($_) } @list;
  
  Returns false otherwise, or if LIST is empty.
  
  =item all BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK, or if LIST is empty. Sets C<$_> for each item in LIST in turn:
  
      print "All items defined"
          if all { defined($_) } @list;
  
  Returns false otherwise.
  
  =item none BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK, or if LIST is empty. Sets C<$_> for each item
  in LIST in turn:
  
      print "No value defined"
          if none { defined($_) } @list;
  
  Returns false otherwise.
  
  =item notall BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
      print "Not all values defined"
          if notall { defined($_) } @list;
  
  Returns false otherwise, or if LIST is empty.
  
  =item true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
      printf "%i item(s) are defined", true { defined($_) } @list;
  
  =item false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
      printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =item firstidx BLOCK LIST
  
  =item first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 4, 3, 2, 4, 6);
      printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
      __END__
      item with index 1 in list is 4
      
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =item lastidx BLOCK LIST
  
  =item last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 4, 3, 2, 4, 6);
      printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
      __END__
      item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =item insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
      my @list = qw/This is a list/;
      insert_after { $_ eq "a" } "longer" => @list;
      print "@list";
      __END__
      This is a longer list
  
  =item insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
      my @list = qw/This is a list/;
      insert_after_string "a", "longer" => @list;
      print "@list";
      __END__
      This is a longer list
  
  =item apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
      my @list = (1 .. 4);
      my @mult = apply { $_ *= 2 } @list;
      print "\@list = @list\n";
      print "\@mult = @mult\n";
      __END__
      @list = 1 2 3 4
      @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
      for (my @mult = @list) { $_ *= 2 }
  
  =item before BLOCK LIST
  
  Returns a list of values of LIST upto (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =item before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =item after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
      @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =item after_incl BLOCK LIST
  
  Same as C<after> but also inclues the element for which BLOCK is true.
  
  =item indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
      @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =item firstval BLOCK LIST
  
  =item first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_val> is an alias for C<firstval>.
  
  =item lastval BLOCK LIST
  
  =item last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_val> is an alias for C<lastval>.
  
  =item pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
      @a = (1 .. 5);
      @b = (11 .. 15);
      @x = pairwise { $a + $b } @a, @b;	# returns 12, 14, 16, 18, 20
  
      # mesh with pairwise
      @a = qw/a b c/;
      @b = qw/1 2 3/;
      @x = pairwise { ($a, $b) } @a, @b;	# returns a, 1, b, 2, c, 3
  
  =item each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
      my $ea = each_array(@a, @b, @c);
      while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it retuns
  the index of the last fetched set of values, as a scalar.
  
  =item each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =item natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
      my @x = ('a' .. 'g');
      my $it = natatime 3, @x;
      while (my @vals = $it->())
      {
          print "@vals\n";
      }
  
  This prints
  
      a b c
      d e f
      g
  
  =item mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =item zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
      @x = qw/a b c d/;
      @y = qw/1 2 3 4/;
      @z = mesh @x, @y;	    # returns a, 1, b, 2, c, 3, d, 4
  
      @a = ('x');
      @b = ('1', '2');
      @c = qw/zip zap zot/;
      @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =item uniq LIST
  
  =item distinct LIST
  
  Returns a new list by stripping duplicate values in LIST. The order of
  elements in the returned list is the same as in LIST. In scalar context,
  returns the number of unique elements in LIST.
  
      my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
      my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
  
  =item minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =item part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
      my $i = 0;
      my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
      my @part = part { 2 } 1 .. 10;	    # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
      my @part = part { -1 } 1 .. 10;
      __END__
      Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
      my @idx  = ( 0, 1, -1 );
      my $i    = 0;
      my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =back
  
  =head1 EXPORTS
  
  Nothing by default. To import all of this module's symbols, do the conventional
  
      use List::MoreUtils ':all';
  
  It may make more sense though to only import the stuff your program actually
  needs:
  
      use List::MoreUtils qw{ any firstidx };
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=List-MoreUtils>
  
  =head1 THANKS
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete. 
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * List::Util export pass-through
  
  Allow B<List::MoreUtils> to pass-through the regular L<List::Util>
  functions to end users only need to C<use> the one module.
  
  =item * uniq_by(&@)
  
  Use code-reference to extract a key based on which the uniqueness is
  determined. Suggested by Aaron Crane.
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.4 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
DARWIN-2LEVEL_LIST_MOREUTILS

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use strict;
use warnings;
use IPC::Run qw(run);
use List::MoreUtils qw(any);
use File::Basename;

my $n;

if ($ARGV[0] && $ARGV[0] eq '-n') {
    (undef, $n) = splice @ARGV, 0, 2;
}

shift if $ARGV[0] eq '--';

my $exe = basename $0;
$exe =~ s/^undead// or undef $exe;

my @command = @ARGV or die 'command args required';
my $config = do '.undeadrc.pl' or die 'Cannot load .undeadrc.pl';

$n = $config->{count} unless defined $n;

my $out = '';
my $err = '';

run(
    ($exe ? [ $exe, @command ] : [ @command ]),
    \*STDIN,
    \$out,
    \$err
);

my @out = $out =~ /(.+)/gm;
my @err = $err =~ /(.+)/gm;

my $exit_code = $? >> 8;

if ($exit_code != 0 && $n > 0) {
    # This was a failure exit and retry count remains > 0

    my $retry = 0;
    $retry ||= any { match($_, $config->{pattern}->{stderr}) } @err;
    $retry ||= any { match($_, $config->{pattern}->{stdout}) } @out;

    if ($retry) {
        print STDERR "# [undead] err - $_" for @err;
        print STDERR "# [undead] out - $_" for @out;
        print STDERR "# [undead] Retry '@command' (", $n-1, " remains)\n";

        exec $^X, $0, '-n' => $n-1, @command;
    }
}

# It was a normal exit, or no more retry remained, or no retry condition matched
print STDERR for @err;
print STDOUT for @out;

exit $exit_code;

sub match ($$) {
    my ($in, $pattern) = @_;

    if (ref $pattern eq 'ARRAY') {
        return any { match($in, $_) } @$pattern;
    } else {
        $pattern = qr/^\Q$pattern\E$/ unless ref $pattern;
        return $in =~ m/$pattern/;
    }
}

__END__

=head1 NAME

undead

=head1 DESCRIPTION

C<< undead >> runs a command and re-runs it on occasional, uncontrollable failure exits.

=head1 SYNOPSIS

  undead [-n <retry count>] command args...

Rename/symlink C<< undead >> to undeadI<< prog >>, to invoke I<< prog >> implicitly. eg.

  undeadperl mayfail.pl

=head1 CONFIGURATION

Place .undeadrc.pl in $PWD with content for example:

  {
      pattern => {
          stderr => [
              qr/^PhantomJS has crashed\./,
          ]
      },
      count => 20,
  };
